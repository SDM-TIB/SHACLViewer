{% include 'base.jinja2' %}
{% block headbase %}

    <link rel="stylesheet" href="{{ url_for('static', filename='css/base_graph.css') }}">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/jquery.dataTables.min.css') }}">

    <style> body {
        margin: 0;
    } </style>

    <script src="{{ url_for('static', filename='js/libs/jquery.dataTables.min.js') }}"></script>

    {% block head %}{% endblock %}
{% endblock %}

{% block title %}
    <title>{{ request.args.get("path") }} Graph</title>
{% endblock %}

{% block body %}
    <span id="optionBtn" class="option-btn">&#9776; Options</span>
    <div id="mySidenav" class="sidenav leftnav closeLeftNav">
        <div class="wrapper">
            <div id="search-wrapper" class="search-input">
                <a id="search-linkTag" href="" target="_blank" hidden></a>
                <input id="search-input" type="text" placeholder="Search for Shape...">
                <div id="search-sugg" class="autocom-box">
                </div>
                <div id="search-icon" class="icon"><i class="fas fa-search"></i></div>
            </div>
        </div>
        <a href="javascript:void(0)" id="hideUnrelatedClasses"><i class=''></i>Show Selected Shape Only
            <label class="switch">
                <input type="checkbox" disabled="disabled">
                <span class="slider round"></span>
            </label>
        </a>
        <a href="javascript:void(0)" id="highlightSelectedNode"><i class=''></i>Highlight Selected
            <label class="switch">
                <input type="checkbox" disabled="disabled" checked>
                <span class="slider round"></span>
            </label>
        </a>
        <a href="javascript:void(0)" id="focusNode"><i class="fas fa-crosshairs option-icon"></i> Focus Selected Shape</a>
        <a href="javascript:void(0)" id="centerGraph"><i class="fas fa-expand option-icon"></i> Center Graph</a>
        <a href="javascript:void(0)" id="expandAll"><i class="fa fa-expand-arrows-alt option-icon" aria-hidden="true"></i> Expand All</a>
        <a href="javascript:void(0)" id="collapseAll"><i class='fas fa-compress-arrows-alt option-icon'></i> Collapse All</a>
        <a href="javascript:void(0)" id="hideAttributes"><i class=''></i> Hide Intra-Constraints
            <label class="switch">
                <input type="checkbox" disabled="disabled">
                <span class="slider round"></span>
            </label>
        </a>
        <button class="accordion">Links Length</button>
        <div class="slider-container panel">
            <label for="class2classLinkSlider">Shape to Shape link</label>
            <input type="range" class="range-style" id="class2classLinkSlider" min="0" max="200">
            <output>150</output>
            <label for="attributeLinkSlider">Shape to Intra-Constraint link</label>
            <input type="range" class="range-style" id="attributeLinkSlider" min="0" max="200">
            <output>150</output>
            <label for="toConstraintLinkSlider">Shape to Inter-Constraint link</label>
            <input type="range" class="range-style" id="toConstraintLinkSlider" min="0" max="200">
            <output>150</output>
            <label for="fromConstraintLinkSlider">Inter-Constraint to Shape link</label>
            <input type="range" class="range-style" id="fromConstraintLinkSlider" min="0" max="200">
            <output>150</output>
        </div>
        <button class="accordion">Validation Intensity Categorization</button>
        <div class="slider-container panel">
            <label for="lowValidationPercentage">Low Invalid Percentage</label>
            <input type="range" class="range-style" id="lowValidationPercentage" min="0" max="100">
            <output>60</output>
            <label for="HighValidationPercentage">High Invalid Percentage</label>
            <input type="range" class="range-style" id="HighValidationPercentage" min="0" max="100">
            <output>90</output>
        </div>
    </div>
    <div id="topRightButtons" style="display: none;">
        <button id="closeDataGraph" class="btn btn-block btn-right-nav btn-primary"
                style="display: block;max-width: 180px;margin-right: 52px;">Back to Data Table
        </button>
    </div>
    <div id="rightTabs">
        <span id="infoBtn" class="right-tab-btn">Info</span>
        <span id="shapeBtn" class="right-tab-btn">Shapes</span>
        <span id="validationBtn" class="right-tab-btn">Validation</span>
    </div>
    <div id="myRightSidenav" class="sidenav rightnav closeRightNav">
        <div id="infoMenu">
            <button class="accordion active">Meta Data</button>
            <div class="slider-container panel">
                <div id="infoStatistic"></div>
            </div>
            <button class="accordion active">Constraints</button>
            <div class="slider-container panel">
                <div id="infoTree"></div>
            </div>
        </div>
        <div id="nodeChecklist">
            <ul></ul>
        </div>
        <div id="validationMenu">
            <button id="ValidationEndpointAccordion" class="accordion active">Validation Endpoint</button>
            <div id="validationEndpointWrapper" class="wrapper slider-container panel"
                 style="overflow: visible;">
                <div style="padding: 10px 0px;">
                    <div id="endpointWrapper" class="search-input">
                        <a id="endpointLinkTag" href="" target="_blank" hidden></a>
                        <input id="endpointInputBox" type="text" placeholder="Endpoint Address...">
                        <div id="endpointSuggBox" class="autocom-box">
                        </div>
                        <div id="endpointIcon" class="icon"><i class="fas fa-angle-down"></i></div>
                    </div>
                </div>
            </div>
            <button class="accordion active">Total Validation Data</button>
            <div class="slider-container panel">
                <div id="totalValidationData"></div>
            </div>
            <button class="accordion active">Selected Shape Data</button>
            <div class="slider-container panel">
                <div id="selectedValidationRequest">
                    <button id="requestValidationBtn" class="btn btn-primary btn-block btn-right-nav" style="display:none;">Request Validation</button>
                </div>
                <div id="selectedValidationData"></div>
                <button id="ViewDataBtn" class="btn btn-primary btn-block btn-right-nav" style="display:none;">View Data</button>
            </div>
        </div>
    </div>
    <div id="main">
        <div id="3d-graph" style="position: absolute;top: 0;"></div>
        <div id="data-table-container"
             style="display: none; padding: 0px 60px 15px 15px; transition: margin 0.5s ease 0s;">
            <button id="close-table-btn" class="btn btn-primary btn-block"
                    style="display: block;max-width: 96px;right: 0;float: right;margin: 10px 0px;">Close
            </button>
            <div id="data-table"></div>
        </div>
        <div id="loader" class="loader"></div>
        <script type="module">
            import { CSS2DRenderer } from 'CSS2DRenderer';
            import SpriteText from 'SpriteText';

            const nodes = [],
                  GROUPS = 1,
                  links = [],
                  none = 'None',
                  backupNodes = [],
                  backupLinks = [];
            let currentNode,
                selectedNode,
                bachupSelectedNode,
                isShowingDataGraph = false,
                node_name;

            {# linkType:
               0: class to class
               1: class to attribute
               2: attribute to same class
               3: class to constraint
               4: constraint to other class
             #}
            {% for node in graph %}
                {# add class/shape node #}
                node_name = '{{ node.id }}';
                if(node_name.includes('&lt;')) { node_name = node_name.substring(4, node_name.length -4)}
                currentNode = {
                    id: '{{ node.id }}',
                    group: '{{ node.id }}',
                    text: node_name,
                    isClass: true,
                    expanded: false,
                    isHidden: false,
                    highlighted: false,
                    childLinks: [],
                    parentLinks: [],
                    query: '{{ node.targetQuery|safe }}',
                    prefix: '{{ node.prefixes|safe }}',
                    targetDef: '{{ node.targetDef }}',
                    valid: -1,
                    invalid: -1,
                    columns: [],
                    data: [],
                    colorRange: 0 {# 0:unvalidated, 1:allValid, 2:low, 3:medium, 4:high, 5:validating #}
                }
                nodes.push(currentNode);

                {% set same_curv = namespace(value=20) %}
                {% set same_rot = namespace(value=0) %}
                {% set link_count = namespace(value=-1) %}
                {% set curv = namespace(value=0) %}
                {% set rot = namespace(value=0) %}
                {% for link in node.get_constraints() %}
                    {% set link_node_name = link.path %}
                    {% set link_count.value = link_count.value + 1 %}

                    {% if none == link.shapeRef %}
                        {# link goes to the same node #}
                        {% set same_curv.value = same_curv.value + 2 %}
                        {% set same_rot.value = same_rot.value + 2 %}
                        {# add constraint as node #}
                        nodes.push({
                            id: '{{ node.id }},{{ link_count.value }}-{{ link.path }}',
                            group: '{{ node.id }}',
                            text: '{{ link_node_name }}',
                            min: '{{ link.min }}',
                            max: '{{ link.max }}',
                            isClass: false,
                            expanded: true,
                            isHidden: false,
                            highlighted: false,
                            childLinks: [],
                            parentLinks: [],
                            isAttribute: true
                        });
                        links.push({
                            id: '1|linkOutToConstraint,{{ node.id }},{{ link_count.value }}-{{ link.path }}',
                            source: '{{ node.id }}',
                            target: '{{ node.id }},{{ link_count.value }}-{{ link.path }}',
                            text: '{{ link_node_name }}',
                            min: '{{ link.min }}',
                            max: '{{ link.max }}',
                            isClass2Class: false,
                            collapsed: true,
                            isHidden: false,
                            highlighted: false,
                            length: 25,
                            isAttribute: true,
                            linkType: 1
                        });
                    {% else %}
                        {# link goes to another node #}
                        links.push({
                            id: '0|{{ link_count.value }}.linkClass:{{ node.id }},toClass:{{ link.shapeRef }}',
                            source: '{{ node.id }}',
                            target: '{{ link.shapeRef }}',
                            text: '{{ link_node_name }}',
                            min: '{{ link.min }}',
                            max: '{{ link.max }}',
                            isClass2Class: true,
                            collapsed: false,
                            isHidden: false,
                            highlighted: false,
                            particles: 0,
                            curvature: 0.2,
                            rotation:{{ rot.value/10 }},
                            length: 100,
                            isAttribute: false,
                            linkType: 0
                        })

                        {# add a constraint as a node and connect it both classes #}
                        nodes.push({
                            id: '{{ node.id }},{{ link_count.value }}-{{ link.path }}',
                            group: '{{ node.id }}',
                            text: '{{ link_node_name }}',
                            min: '{{ link.min }}',
                            max: '{{ link.max }}',
                            isClass: false,
                            expanded: true,
                            isHidden: false,
                            highlighted: false,
                            childLinks: [],
                            parentLinks: [],
                            isAttribute: false
                        });
                        links.push({
                            id: '3|linkToConstraintFrom,{{ node.id }},To,{{ node.id }},{{ link_count.value }}-{{ link.path }}',
                            source: '{{ node.id }}',
                            target: '{{ node.id }},{{ link_count.value }}-{{ link.path }}',
                            finalTarget: '{{ link.shapeRef }}',
                            text: '{{ link_node_name }}',
                            min: '{{ link.min }}',
                            max: '{{ link.max }}',
                            isClass2Class: false,
                            collapsed: true,
                            isHidden: false,
                            highlighted: false,
                            particles: 2,
                            length: 25,
                            isAttribute: false,
                            linkType: 3
                        })
                        links.push({
                            id: '4|linkFromConstraint,{{ node.id }},{{ link_count.value }}-{{ link.path }},To,{{ link.shapeRef }}',
                            source: '{{ node.id }},{{ link_count.value }}-{{ link.path }}',
                            target: '{{ link.shapeRef }}',
                            text: '{{ link_node_name }}',
                            min: '{{ link.min }}',
                            max: '{{ link.max }}',
                            isClass2Class: false,
                            collapsed: true,
                            isHidden: false,
                            highlighted: false,
                            particles: 2,
                            length: 50,
                            isAttribute: false,
                            linkType: 4
                        })
                        {% set curv.value = curv.value + 1 %}
                        {% set rot.value = rot.value + 12 %}
                    {% endif %}
                {% endfor %}
            {% endfor %}

            class Statistics {
                attributes = 0;
                constraints = 0;
                partOff = 0;
                constructor(){}
            }

            const nodesById = {},
                  linksById = {};
            resetGraphMaps()

            function resetGraphMaps(removeDuplicates) {
                {# clear #}
                Object.keys(nodesById).forEach(key => delete nodesById[key]);
                Object.keys(linksById).forEach(key => delete linksById[key]);
                {# refill #}
                Object.assign(nodesById, Object.fromEntries(nodes.map(node => [node.id, node])));
                Object.assign(linksById, Object.fromEntries(links.map(link => [link.id, link])));

                if (removeDuplicates) {
                    nodes.length = 0;
                    nodes.push(...Object.values(nodesById));
                }

                {# clear node lists #}
                nodes.forEach(n => {
                    n.childLinks = [];
                    n.parentLinks = [];
                })
                {# fill nodes' lists #}
                links.forEach(link => {
                    getNodeFromLink(link.source).childLinks.push(link);
                    getNodeFromLink(link.target).parentLinks.push(link);
                });
                nodes.forEach(node => {
                    const stat = new Statistics();
                    node.childLinks.forEach(link => {
                        if (link.isClass2Class)
                            stat.constraints++;
                        else if (link.isAttribute)
                            stat.attributes++;
                    })
                    node.parentLinks.forEach(link => {
                        if (link.isClass2Class)
                            stat.partOff++;
                    })
                    node.statistics = stat;
                })
            }

            function updateClassState(node) {
                {# foreach link to this node show/hide the links to classes and hide/show links to constraint and their links #}
                node.childLinks.forEach(link => {
                    if (link.isClass2Class) {
                        {# if node not expanded => show link to other classes #}
                        link.collapsed = node.expanded;
                        if (hideUnrelatedClasses) { link.isHidden = false; }
                    } else {  {# links to constraint #}
                        link.collapsed = !node.expanded;
                        let constraint = getNodeFromLink(link.target);
                        constraint.expanded = !node.expanded;
                        if (!constraint.isClass) {# so when clicking on constraint it wont highlight all links of the target node #}
                            constraint.childLinks.forEach(l => {
                                l.collapsed = !node.expanded
                                if (hideUnrelatedClasses) { {# show links and constraints of clicked nodes because now they are related #}
                                    l.isHidden = false;
                                    let target = getNodeFromLink(l.target);
                                    target.isHidden = false;

                                    target.childLinks.forEach(cl => { {# show links to already shown nodes #}
                                        if (cl.isClass2Class) {
                                            cl.isHidden = getNodeFromLink(cl.target).isHidden
                                        }
                                    });
                                    target.parentLinks.forEach(cl => { {# show links to already shown nodes #}
                                        if (cl.isClass2Class) {
                                            cl.isHidden = getNodeFromLink(cl.source).isHidden
                                        }
                                    });
                                }
                            });

                        if (hideUnrelatedClasses) { {# show links and constraints of clicked nodes because now they are related #}
                            link.isHidden = false;
                            constraint.isHidden = false;
                        }
                    }
                })
                updateGraph();
            }

            function getNodeFromLink(linkTarget) {
                {# before drawing for the first time the link.target is just a string, after that it will be an object #}
                if ((typeof linkTarget) === 'object') {
                    return linkTarget
                } else {
                    let res = nodesById[linkTarget]
                    if ((typeof res) === 'object')
                        return nodesById[linkTarget]
                    else {
                        {# manual search because getNodeFromLink didn't work on the current nodesById map #}
                        for (let i = 0; i < backupNodes.length; i++) {
                            if (backupNodes[i].id == linkTarget)
                                return backupNodes[i];
                        }
                    }
                }
            }

            function highlightNode(node) {
                if (highlightSelectedNode) {
                    nodes.forEach(n => n.highlighted = false)
                    links.forEach(l => l.highlighted = false)
                    node.highlighted = true;
                    if (node.isClass) {
                        node.childLinks.forEach(link => {
                            link.highlighted = true;
                            if (!link.isClass2Class) {
                                let constraintNode = getNodeFromLink(link.target);
                                constraintNode.highlighted = true;
                                constraintNode.childLinks.forEach(l => l.highlighted = true)
                            }
                        })
                    } else {
                        node.childLinks.forEach(link => link.highlighted = true);
                        node.parentLinks.forEach(link => link.highlighted = true);
                    }
                    updateNode3d()
                }
            }

            let hideAttributes = false;

            function updateGraph() { Graph.graphData(getVisibleLists()) }

            function getVisibleLists() {
                const visibleNodes = [],
                      visibleLinks = [];

                let enableUpdate = false;

                if (document.getElementById('nodeChecklist').getElementsByTagName('ul')[0].innerHTML !== "")
                    enableUpdate = true;

                nodes.forEach(node => {
                    // check hideAttributes feature
                    if (!node.isAttribute || (node.isAttribute && !hideAttributes))
                        if (!node.isHidden)
                            if (!node.expanded || node.isClass)
                                visibleNodes.push(node)

                    // update check list
                    if (enableUpdate && node.isClass)
                        if (node.isHidden)
                            shapeCheckList[node.id].classList.remove('checked');
                        else
                            shapeCheckList[node.id].classList.add('checked');
                });
                links.forEach(link => {
                    // check hideAttributes feature
                    if (!link.isAttribute || (link.isAttribute && !hideAttributes))
                        if (!link.isHidden && !link.collapsed)
                            visibleLinks.push(link)
                });

                updateNode3d();
                return {nodes: visibleNodes, links: visibleLinks};
            }

            function debugNode(node) {
                console.log('debugNode|')
                console.log(node)
            }

            function debugLink(link) {
                console.log('debugLink|')
                console.log(link)
            }

            {% block graph_implementation %}{% endblock %}

            // link length
            const linkForce = Graph.d3Force('link').distance(link => getLinkLength(link.linkType));

            function getLinkLength(linkType) {
                switch (linkType) {
                    case 0:
                        return settings.linkLengthClass2Class
                    case 1:
                        return settings.linkLengthAttribute
                    case 3:
                        return settings.linkLengthToConstraint
                    case 4:
                        return settings.linkLengthFromConstraint
                    default:
                        return 1
                }
            }

            let isRightNavOpenedBefore = false;

            function onNodeClicked(node) {
                {# if showing data graph and the node is not retrieved #}
                if (isShowingDataGraph && node.isClass && !node.retrieved) {
                    {# get the shape data and recall this function #}
                    updateDataGraph(node, function() { onNodeClicked(node) })
                    return
                }

                if (node === selectedNode && node.isClass) {
                    node.expanded = !node.expanded; // toggle collapse state
                    console.log('if node.isClass| ' + node.id + '.expanded ' + node.expanded)
                    updateClassState(node);
                }

                {# show all edges on node focus that was been hidden #}
                if (hideUnrelatedClasses) {
                    console.log("onNodeClicked | hideUnrelatedClasses | show all edges")
                    node.childLinks.forEach(link => {
                        if (node.expanded) {
                            if (link.linkType == 3) {
                                link.isHidden = false;
                                getNodeFromLink(link.target).isHidden = false;
                                getNodeFromLink(link.finalTarget).isHidden = false;
                            }
                        } else {
                            if (link.linkType == 0) {
                                link.isHidden = false;
                                getNodeFromLink(link.target).isHidden = false;
                            }
                        }
                    })
                    updateHiddenLinks();
                    updateGraph(); {# to show links between the new shown classes #}
                }

                // open info panel for the first time
                if (!isRightNavOpenedBefore) {
                    openRightNav('info');
                    isRightNavOpenedBefore = true;
                }

                viewNodeInfo(node);
                fillValidationData();
                highlightNode(node);
            }

            import {BootstrapTreeView} from '{{ url_for('static', filename='js/libs/simple-treeview.bootstrap.min.js') }}';

            {# fill info menu #}
            function viewNodeInfo(node) {
                // fill statistics
                let stat = document.getElementById('infoStatistic')
                if (node.isClass) {
                    stat.innerHTML = '<p>Intra-Constraints: '
                        + node.statistics.attributes
                        + '</p><p>Inter-Constraints: '
                        + node.statistics.constraints
                        + '</p><p>Constraints targeting this shape: '
                        + node.statistics.partOff
                        + '</p><p>Target: '
                        + node.targetDef + '</p>';
                } else {
                    let range = "<p>"
                    if (node.min != "-1") {
                        if (node.min === node.max)
                            range += "equal: " + node.min
                        else {
                            range += "min: " + node.min
                            if (node.max != "-1") {
                                range += "</p><p>max: " + node.max
                            }
                        }
                    } else if (node.max != "-1") {
                        range += "max: " + node.max
                    }
                    stat.innerHTML = range + '</p>';
                }

                // fill constraints
                document.getElementById('infoTree').innerHTML = "";
                new BootstrapTreeView(document.getElementById('infoTree'), {
                    provider: {
                        async getChildren(id) {
                            console.log('Info navigation| id: ' + id)
                            if (!id) { {# a node on the graph is clicked #}
                                selectedNode = node;
                                return [
                                    {
                                        id: node.id,
                                        label: node.text,
                                        icon: {classes: ['fa', 'fa-project-diagram']},
                                        state: 'expanded'
                                    }
                                ];
                            } else {
                                {#if the clicked element is a node#}
                                const n = nodesById[id];
                                if (n) {
                                    function sub_callback(n) {
                                        const res = [];
                                        const resSelf = [];

                                        if (n.isHidden) {
                                            n.isHidden = false;
                                            updateHiddenLinks();
                                            updateClassState(n);
                                        } else if (n != selectedNode && !n.expanded && !isShowingDataGraph) { {# expand the node in graph #}
                                            n.expanded = true;
                                            updateClassState(n);
                                        }

                                        {# fill info menu with node connections #}
                                        if (n.isClass) {
                                            n.childLinks.forEach(link => {
                                                if (!link.isClass2Class) { {# if the link goes to a constraint #}
                                                    if (link.isAttribute) { {# if the link goes to self constaint #}
                                                        resSelf.push({
                                                            id: link.id,
                                                            label: link.text,
                                                            icon: {classes: ['bi', 'bi-align-middle']},
                                                            state: 'collapsed'
                                                        })
                                                    } else { {# the link goes to another class #}
                                                        res.push({
                                                            id: link.id,
                                                            label: link.text,
                                                            icon: {classes: ['bi', 'bi-arrow-left-right']},
                                                            state: 'collapsed'
                                                        });
                                                    }
                                                }
                                            })
                                            resSelf.push(...res)
                                            return resSelf;
                                        } else { {# the node is a constraint => show attributes #}
                                            id = n.parentLinks[0].id
                                        }
                                    }

                                    if (isShowingDataGraph && n.isClass && !n.retrieved) {
                                        {# get the shape data and recall this function #}
                                        updateDataGraph(n, function () { return sub_callback(n) })
                                    } else { return sub_callback(n) }
                                }

                                {#if the clicked element is a link#}
                                const l = linksById[id];
                                if (l) {
                                    console.log('if the clicked element is a link| ' + l)
                                    let return_list = []

                                    let range = ""
                                    if (l.min != "-1") {
                                        if (l.min === l.max)
                                            range += "equal: " + l.min
                                        else {
                                            range += "min: " + l.min
                                            if (l.max != "-1") {
                                                range += ", max: " + l.max
                                            }
                                        }
                                    } else if (l.max != "-1") {
                                        range += "max: " + l.max
                                    }

                                    if (range != "") {
                                        return_list.push({
                                            id: l.id + ",range",
                                            label: range,
                                            icon: {classes: ['fa', 'fa-drafting-compass']}
                                        })
                                    }

                                    if (l.finalTarget) { {# if the link goes to constraint #}
                                        const ft = nodesById[l.finalTarget];
                                        {# TODO check it undefined when clicking on constraint: id: ft.id, #}
                                        return_list.push({
                                            id: ft.id,
                                            label: ft.text,
                                            icon: {classes: ['fa', 'fa-project-diagram']},
                                            state: 'collapsed'
                                        })
                                    } else if (isShowingDataGraph) {
                                        if (l.linkType == 1)
                                            return_list.push({
                                                id: l.id + ",text",
                                                label: getNodeFromLink(l.target).text,
                                                icon: {classes: ['fa-regular', 'fa-file-lines']}
                                            })
                                    }
                                    return return_list;
                                }
                                return []; {# if not found #}
                            }
                        }
                    }
                });
            }

            // shape check list
            const shapeCheckList = {};
            resetShapeCheckList();

            function resetShapeCheckList() {
                const checklist = document.getElementById('nodeChecklist').getElementsByTagName('ul');
                checklist[0].innerHTML = "";

                // Add a "checked" symbol on click
                checklist[0].addEventListener('click', function (ev) {
                    if (ev.target.tagName === 'LI') {
                        ev.target.classList.toggle('checked');

                        if (ev.target.classList.contains('checked')) {
                            let node = nodesById[ev.target.getAttribute('nodeId')]

                            node.isHidden = false;
                        } else {
                            let node = nodesById[ev.target.getAttribute('nodeId')]
                            node.isHidden = true;
                            node.childLinks.forEach(link => {
                                link.isHidden = true;
                                switch (link.linkType) {
                                    case 0:
                                        break;
                                    case 1:
                                        getNodeFromLink(link.target).isHidden = true;
                                        break;
                                    case 3:
                                        let constraint = getNodeFromLink(link.target);
                                        constraint.isHidden = true;
                                        constraint.childLinks[0].isHidden = true;
                                        break;
                                }
                            })
                        }
                        updateHiddenLinks();
                        updateGraph();
                    }
                }, false);

                nodes.forEach(node => {
                    if (node.isClass) {
                        const li = document.createElement("li");
                        li.setAttribute('nodeId', node.id);
                        li.appendChild(document.createTextNode(node.text));
                        checklist[0].appendChild(li);
                        if (!node.isHidden) { li.classList.add('checked') }
                        shapeCheckList[node.id] = li;
                    }
                });
            }

            function updateHiddenLinks() {
                links.forEach(link => {
                    // update links if the nodes are hidden or not
                    switch (link.linkType) {
                        case 3:
                            let source = getNodeFromLink(link.source)
                            let constraint = getNodeFromLink(link.target)
                            let finalTarget = getNodeFromLink(link.finalTarget)
                            if (source.isHidden || finalTarget.isHidden) {
                                constraint.isHidden = true;
                                constraint.parentLinks.forEach(l => l.isHidden = true)
                                constraint.childLinks.forEach(l => l.isHidden = true)
                            } else {
                                constraint.isHidden = false;
                                constraint.parentLinks.forEach(l => l.isHidden = false)
                                constraint.childLinks.forEach(l => l.isHidden = false)
                            }
                            break;
                        case 1: {# do nothing to attributes #}
                            if (getNodeFromLink(link.source).isHidden) {
                                link.isHidden = true;
                                getNodeFromLink(link.target).isHidden = true;
                            } else {
                                link.isHidden = false;
                                getNodeFromLink(link.target).isHidden = false;
                            }
                            break;
                        default:
                            link.isHidden = (getNodeFromLink(link.source).isHidden || getNodeFromLink(link.target).isHidden);
                            break;
                    }
                });
            }

            {# validation #}
            function requestValidationData(node) {
                console.log("requestValidationData")
                let endpoint = endpointInputBox.value
                if (endpoint === "") {
                    $('#flash').append(flashMessage("Select the validation endpoint", 'warning'));
                    openAccordion(document.querySelector('#ValidationEndpointAccordion'))
                    endpointInputBox.focus();
                    return false;
                }

                let dir = "{{ request.args.get("path") }}";
                let config = {
                    external_endpoint: endpoint,
                    outputDirectory: "./output/",
                    query: "PREFIX ub:<http://swat.cse.lehigh.edu/onto/univ-bench.owl#> PREFIX :<http://example.com/>" + node.query,
                    schemaDir: "/shapes" + dir,
                    targetShape: node.id.replace("&lt;", "<").replace("&gt;", ">"),
                    backend: "travshacl",
                    output_format: "test"
                }

                console.log("query:" + config.query)
                console.log("node.query:" + node.query)
                console.log("targetShape:" + config.targetShape)

                let request_validation = $.ajax({
                    url: "/validation",
                    type: "POST",
                    data: config,
                    success: function (data, textStatus, jqXHR) {
                        console.log("validation request success")
                        console.log(data)
                        console.log(textStatus)
                        console.log(jqXHR)

                        //save endpoint to cache
                        saveToCache(endpointInputBox.id, endpoint)

                        {# get current shape node #}
                        let currentNode;
                        if (selectedNode.isClass)
                            currentNode = selectedNode;
                        else
                            currentNode = selectedNode.parentLinks[0];

                        Object.keys(data).forEach(shapeId => {
                            let shape = nodesById[shapeId]
                            {# fill valid/invalid count #}
                            shape.valid = data[shapeId].valid
                            shape.invalid = data[shapeId].invalid
                            {# calculate validation percent #}
                            if (shape.valid === 0 && shape.invalid === 0)
                                shape.validPercent = 100
                            else
                                shape.validPercent = Math.floor(10000 * shape.valid / (shape.valid + shape.invalid)) / 100;
                            {# fill data #}
                            shape.columns = data[shapeId].columns
                            shape.data = data[shapeId].results

                            validationData.add(shape)

                            {# request returned so remove it from request map #}
                            delete requestMap[shapeId];

                            {# update validation tab #}
                            if (shapeId.replace("<", "&lt;").replace(">", "&gt;") === currentNode.id) {
                                fillValidationData()
                            } else
                                {# only update total validation data in the validation tab #}
                                updateTotalValidation()
                        })
                        requestBtnClicked(false);
                    },
                    error: function (jqXHR, exception) {
                        console.log("validation request error:")
                        console.log(jqXHR.status)
                        console.log(exception)
                        let msg = '';
                        if (jqXHR.status === 0) {
                            msg = ': Cannot connect to shaclAPI';
                        } else if (jqXHR.status === 404) {
                            msg = ': Requested page not found. [404]';
                        } else if (jqXHR.status === 500) {
                            msg = ': Internal Server Error [500].';
                        } else if (exception === 'parsererror') {
                            msg = ': Requested JSON parse failed.';
                        } else if (exception === 'timeout') {
                            msg = ': Time out error.';
                        } else if (exception === 'abort') {
                            msg = ': Ajax request aborted.';
                        } else {
                            msg = ': Uncaught Error.\n' + jqXHR.responseText;
                        }
                        $('#flash').append(flashMessage(node.id + msg, 'warning'));

                        {# request returned so remove it from request map #}
                        delete requestMap[node.id];

                        let currentNode;
                        if (selectedNode.isClass)
                            currentNode = selectedNode;
                        else
                            currentNode = selectedNode.parentLinks[0];

                        if (node.id.replace("<", "&lt;").replace(">", "&gt;") === currentNode.id) { requestBtnClicked(false) }
                    }
                });

                requestMap[node.id] = request_validation
                node.colorRange = 5

                let request_node_list = $.ajax({
                    url: "/reduce",
                    type: "POST",
                    data: config,
                    success: function (data, textStatus, jqXHR) {
                        console.log("reduce result success")
                        console.log(data)
                        console.log(textStatus)
                        console.log(jqXHR)

                        data['shapes'].forEach(shapeId => {
                            let shape = nodesById[shapeId]
                            if (shape.valid === -1 || shape.invalid === -1) {
                                requestMap[shapeId] = request_validation
                                shape.colorRange = 5
                            }
                        })
                        updateNode3d();
                    },
                    error: function (jqXHR, exception) {
                        console.log("reduce result error:")
                        console.log(jqXHR.status)
                        console.log(exception)
                        let msg = '';
                        if (jqXHR.status === 0) {
                            msg = ': Cannot connect to shaclAPI';
                        } else if (jqXHR.status === 404) {
                            msg = ': Requested page not found. [404]';
                        } else if (jqXHR.status === 500) {
                            msg = ': Internal Server Error [500].';
                        } else if (exception === 'parsererror') {
                            msg = ': Requested JSON parse failed.';
                        } else if (exception === 'timeout') {
                            msg = ': Time out error.';
                        } else if (exception === 'abort') {
                            msg = ': Ajax request aborted.';
                        } else {
                            msg = ': Uncaught Error.\n' + jqXHR.responseText;
                        }
                        $('#flash').append(flashMessage(node.id + msg, 'warning'));

                        {# request returned so remove it from request map #}
                        delete requestMap[node.id];

                        let currentNode;
                        if (selectedNode.isClass)
                            currentNode = selectedNode;
                        else
                            currentNode = selectedNode.parentLinks[0];

                        if (node.id.replace("<", "&lt;").replace(">", "&gt;") === currentNode.id) { requestBtnClicked(false) }
                    }
                });

                return true;
            }

            let validationData = {
                settings: {
                    highValidPercent: 10,
                    lowValidPercent: 40
                },
                validatedNodes: [],
                totalShapes: {{ graph|length }},
                totalValid: 0,
                totalInvalid: 0,
                low: 0,
                med: 0,
                high: 0,
                allValid: 0,
                add: function (node) { {# colorRange[ 0:unvalidated, 1:allValid, 2:low, 3:medium, 4:high ] #}
                    if (!this.validatedNodes.includes(node)) {
                        switch (true) {
                            case (node.validPercent < this.settings.highValidPercent):
                                this.high++;
                                node.colorRange = 4;
                                break;
                            case (node.validPercent < this.settings.lowValidPercent):
                                this.med++;
                                node.colorRange = 3;
                                break;
                            case (node.validPercent < 100):
                                this.low++;
                                node.colorRange = 2;
                                break;
                            case (node.validPercent === 100):
                                this.allValid++;
                                node.colorRange = 1;
                                break;
                        }
                        updateNode3d();
                        this.totalValid += node.valid
                        this.totalInvalid += node.invalid
                        this.validatedNodes.push(node)
                    }
                },
                updateRange: function () {
                    {# recalculate low/med/high #}
                    this.low = this.med = this.high = this.allValid = this.totalValid = this.totalInvalid = 0
                    this.validatedNodes.forEach(node => {
                        switch (true) {
                            case (node.validPercent < this.settings.highValidPercent):
                                this.high++;
                                node.colorRange = 4;
                                break;
                            case (node.validPercent < this.settings.lowValidPercent):
                                this.med++;
                                node.colorRange = 3;
                                break;
                            case (node.validPercent < 100):
                                this.low++;
                                node.colorRange = 2;
                                break;
                            case (node.validPercent === 100):
                                this.allValid++;
                                node.colorRange = 1;
                                break;
                        }
                        if (requestMap[node.id]) // node is validating
                            node.colorRange = 5

                        this.totalValid += node.valid
                        this.totalInvalid += node.invalid
                    })
                }
            }

            let requestMap = {};

            function fillValidationData() {
                console.log("fillValidationData")

                {# fill total validation #}
                updateTotalValidation()

                {# fill selected validation #}
                let shapeNode;
                if (selectedNode.isClass)
                    shapeNode = selectedNode;
                else
                    shapeNode = getNodeFromLink(selectedNode.parentLinks[0].source);

                console.log("selectedNode: " + selectedNode.text)
                console.log("selectedNode.isClass: " + selectedNode.isClass)
                console.log("shapeNode: " + shapeNode.text)

                let statNode = document.getElementById('selectedValidationData')
                if (shapeNode.valid < 0) {
                    {# show request button #}
                    document.getElementById('requestValidationBtn').style.display = "block"
                    document.getElementById('ViewDataBtn').style.display = "none"

                    {# check if already requested or not #}
                    if (requestMap[shapeNode.id]) { requestBtnClicked(true) }
                    else { requestBtnClicked(false) }
                    statNode.innerHTML = '' {# clear validation data #}
                } else {
                    {# hide request button #}
                    document.getElementById('requestValidationBtn').style.display = "none"
                    document.getElementById('ViewDataBtn').style.display = "block"

                    {# fill validation data #}
                    statNode.innerHTML =
                        '<p>Valid Percentage:</p>'
                        + "<p style=\'background: linear-gradient(90deg, rgb(0 90 255) 0%, rgb(0 90 255) " + shapeNode.validPercent + "%, rgb(192 0 0) " + shapeNode.validPercent + "%, rgb(192 0 0) 100%);\'"
                        + " class=\'powerbar\'>"
                        + shapeNode.validPercent + "%</p>"
                        + "<table><tr><td>Valid: " + shapeNode.valid + "</td><td>"
                        + "Invalid: " + shapeNode.invalid + "</td></tr></table>";
                }
            }

            function updateTotalValidation() {
                {# fill total validation #}
                let statTotal = document.getElementById('totalValidationData')

                {# calculate low,med,high percent #}
                let total = validationData.allValid + validationData.low + validationData.med + validationData.high
                let allValidP = 100 * validationData.allValid / total;
                let lowP = 100 * (validationData.allValid + validationData.low) / total;
                let medP = 100 * (validationData.allValid + validationData.low + validationData.med) / total;

                let validDataPercent = Math.floor(10000 * validationData.totalValid / (validationData.totalValid + validationData.totalInvalid)) / 100
                if (validationData.totalValid === 0 && validationData.totalInvalid === 0)
                    validDataPercent = 100;

                statTotal.innerHTML =
                    '<p>Shapes processed: ' + validationData.validatedNodes.length + '/' + validationData.totalShapes +
                    '</p>'
                    + "<p style=\'background: linear-gradient(90deg, rgb(0 192 0) 0%, rgb(0 192 0) " + allValidP
                    + "%, rgb(255 255 0) " + allValidP
                    + "%, rgb(255 255 0) " + lowP
                    + "%, rgb(255 128 0) " + lowP
                    + "%, rgb(255 128 0) " + medP
                    + "%, rgb(192 0 0) " + medP
                    + "%, rgb(192 0 0) 100%);\'"
                    + " class=\'powerbar\'>"
                    + "</p>"
                    + "<table><tr><td>Low: " + validationData.low + "</td><td>"
                    + "Medium: " + validationData.med + "</td><td>"
                    + "High: " + validationData.high + "</td></tr></table>"
                    + '<p>Validation Data:</p>'
                    + "<p style=\'background: linear-gradient(90deg, rgb(13 110 253) 0%, rgb(13 110 253) " + validDataPercent
                    + "%, rgb(192 0 0) " + validDataPercent
                    + "%, rgb(192 0 0) 100%);\'"
                    + " class=\'powerbar\'>"
                    + validDataPercent + "%</p>"
                    + "<table><tr><td>Valid: " + validationData.totalValid + "</td><td>"
                    + "Invalid: " + validationData.totalInvalid + "</td></tr></table>";
            }

            function requestBtnClicked(clicked) {
                let btn = document.getElementById('requestValidationBtn');
                if (clicked) {
                    btn.classList.add("sending", "btn-secondary");
                    btn.classList.remove("btn-primary");
                    btn.textContent = "Validating, click to cancel";
                    btn.blur();
                } else {
                    btn.classList.remove("sending", "btn-secondary");
                    btn.classList.add("btn-primary");
                    btn.textContent = "Request Validation";
                    btn.blur();
                }
            }

            // HTML calls
            document.querySelector("#collapseAll").onclick = () => {
                nodes.forEach(node => node.isClass ? node.expanded = false : node.expanded = true);
                links.forEach(link => link.isClass2Class ? link.collapsed = false : link.collapsed = true);
                updateGraph();
            }

            document.querySelector("#expandAll").onclick = () => {
                nodes.forEach(node => node.isClass ? node.expanded = true : node.expanded = false);
                links.forEach(link => link.isClass2Class ? link.collapsed = true : link.collapsed = false);
                updateGraph();
            }

            document.querySelector("#centerGraph").onclick = () => { Graph.zoomToFit(400); }

            document.querySelector("#focusNode").onclick = () => { {# check selected node #}
                if (null == selectedNode) { $('#flash').append(flashMessage(`Select a Shape first`, 'warning')); }
                else { focusNode(selectedNode); }
            }

            let hideUnrelatedClasses = false;
            document.querySelector('#hideUnrelatedClasses').onclick = () => {
                const checkbox = $("#hideUnrelatedClasses").find('input:checkbox:first');
                console.log('hideUnrelatedClasses| checkbox.prop(\'checked\')| ' + checkbox.prop('checked'));

                {# check selected node #}
                if (null == selectedNode) {
                    $('#flash').append(flashMessage(`Select a shape first`, 'warning'));
                    return;
                }

                if (hideUnrelatedClasses) {
                    checkbox.prop('checked', false);
                    hideUnrelatedClasses = false;

                    nodes.forEach(node => node.isHidden = false)
                    links.forEach(link => link.isHidden = false)

                    updateGraph();
                } else {
                    checkbox.prop('checked', true);
                    hideUnrelatedClasses = true;
                    hideAllButSelectedNode();
                }

                openRightNav('shape');  // open node checklist and fill it
            }

            function hideAllButSelectedNode() {
                {# hide all nodes and links #}
                nodes.forEach(node => node.isHidden = true)

                selectedNode.isHidden = false;
                {# get class to class links and show classes #}
                selectedNode.childLinks.forEach(link => {
                    if (link.isClass2Class) {
                        getNodeFromLink(link.target).isHidden = false;
                    }
                });
                updateHiddenLinks();
                updateGraph();
            }

            let highlightSelectedNode = true;
            document.querySelector('#highlightSelectedNode').onclick = () => {
                const checkbox = $("#highlightSelectedNode").find('input:checkbox:first');
                console.log('highlightSelectedNode| checkbox.prop(\'checked\')| ' + checkbox.prop('checked'));

                if (highlightSelectedNode) {
                    checkbox.prop('checked', false);
                    highlightSelectedNode = false;

                    nodes.forEach(node => node.highlighted = false)
                    links.forEach(link => link.highlighted = false)
                    updateNode3d();
                } else {
                    checkbox.prop('checked', true);
                    highlightSelectedNode = true;
                    highlightNode(selectedNode)
                }
            }

            {#Search box#}
            let suggestions = [];
            nodes.forEach(node => node.isClass ? suggestions.push(node.text) : null);

            // getting all required elements
            const searchWrapper = document.querySelector("#search-wrapper"),
                  inputBox = searchWrapper.querySelector("#search-input"),
                  suggBox = searchWrapper.querySelector("#search-sugg"),
                  icon = searchWrapper.querySelector("#search-icon");
            let linkTag = searchWrapper.querySelector("#search-linkTag");

            // if user press any key and release
            inputBox.onkeyup = (e) => { suggest(e); }
            inputBox.onfocus = (e) => {
                inputBox.value = '';
                suggest(e);
            }

            function suggest(e) {
                let userData = e.target.value; //user entered data
                let emptyArray = [];
                icon.onclick = () => { }  // TODO: can this be removed?
                emptyArray = suggestions.filter((data) => {
                    if (userData)
                        // filtering array value and user characters to lowercase and return only those words which are start with user entered chars
                        return data.toLocaleLowerCase().startsWith(userData.toLocaleLowerCase());
                    else
                        return data;
                });
                emptyArray = emptyArray.map((data) => {
                    // passing return data inside li tag
                    return `<li>${data}</li>`;
                });
                searchWrapper.classList.add("active"); //show autocomplete box
                showSuggestions(emptyArray.sort());
                let allList = suggBox.querySelectorAll("li");
                let clicked = false;
                {# fix on mouse out will hide the highlight after clicking #}
                for (let i = 0; i < allList.length; i++) {
                    // adding onclick attribute in all li tag
                    allList[i].onclick = () => {
                        clicked = true;
                        select(allList[i])
                        viewNodeInfo(nodesById[allList[i].textContent])
                        {# viewNodeInfo will set selectedNode #}
                        if (nodesById[allList[i].textContent].isHidden) {
                            if (hideUnrelatedClasses)
                                hideAllButSelectedNode();
                            else {
                                nodesById[allList[i].textContent].isHidden = false;
                                updateHiddenLinks()
                                updateGraph();
                            }
                        } else {
                            updateClassState(nodesById[allList[i].textContent])
                        }
                    };
                    allList[i].onmouseover = () => { highlightSelectedNode ? highlightNode(nodesById[allList[i].textContent]) : null }
                }
                suggBox.onmouseout = () => {
                    if (highlightSelectedNode) {
                        if (clicked) { {# when an item is clicked and searchWrapper disappear dont remove highlight #}
                            clicked = false;
                            return;
                        }
                        nodes.forEach(node => node.highlighted = false)
                        links.forEach(link => link.highlighted = false)
                        updateNode3d();
                    }
                }
            }

            let mouse_is_inside = false;
            searchWrapper.onmouseover = () => { mouse_is_inside = true; }
            searchWrapper.onmouseout = () => { mouse_is_inside = false; }

            document.querySelector("body").onmouseup = () => {
                if (!mouse_is_inside) searchWrapper.classList.remove("active"); // hide autocomplete box
            }

            function select(element) {
                let selectData = element.textContent;
                inputBox.value = selectData;
                icon.onclick = () => {
                    updateClassState(nodesById[selectData])
                    viewNodeInfo(nodesById[selectData])
                }
                searchWrapper.classList.remove("active");
            }

            function showSuggestions(list) {
                let listData;
                if (!list.length) {
                    let userValue = inputBox.value;
                    listData = `<li>${userValue}</li>`;
                } else {
                    listData = list.join('');
                }
                suggBox.innerHTML = listData;
            }

            document.querySelector('#hideAttributes').onclick = () => {
                const checkbox = $("#hideAttributes").find('input:checkbox:first');
                console.log('hideAttributes| checkbox.prop(\'checked\')| ' + checkbox.prop('checked'));

                if (hideAttributes) {
                    checkbox.prop('checked', false);
                    hideAttributes = false;
                    updateGraph();
                } else {
                    checkbox.prop('checked', true);
                    hideAttributes = true;
                    updateGraph();
                }
            }

            // link length slider update value from default settings
            document.querySelector('#class2classLinkSlider').value = settings.linkLengthClass2Class
            document.querySelector('#attributeLinkSlider').value = settings.linkLengthAttribute
            document.querySelector('#toConstraintLinkSlider').value = settings.linkLengthToConstraint
            document.querySelector('#fromConstraintLinkSlider').value = settings.linkLengthFromConstraint
            document.querySelector('#class2classLinkSlider').nextElementSibling.value = settings.linkLengthClass2Class
            document.querySelector('#attributeLinkSlider').nextElementSibling.value = settings.linkLengthAttribute
            document.querySelector('#toConstraintLinkSlider').nextElementSibling.value = settings.linkLengthToConstraint
            document.querySelector('#fromConstraintLinkSlider').nextElementSibling.value = settings.linkLengthFromConstraint
            // link length slider listeners
            document.querySelector('#class2classLinkSlider').oninput = function () {
                this.nextElementSibling.value = this.value
                settings.linkLengthClass2Class = this.value
                updateLinkDistance();
            }
            document.querySelector('#attributeLinkSlider').oninput = function () {
                this.nextElementSibling.value = this.value
                settings.linkLengthAttribute = this.value
                updateLinkDistance();
            }
            document.querySelector('#toConstraintLinkSlider').oninput = function () {
                this.nextElementSibling.value = this.value
                settings.linkLengthToConstraint = this.value
                updateLinkDistance();
            }
            document.querySelector('#fromConstraintLinkSlider').oninput = function () {
                this.nextElementSibling.value = this.value
                settings.linkLengthFromConstraint = this.value
                updateLinkDistance();
            }

            // Validation percentage slider update value from default settings
            document.querySelector('#lowValidationPercentage').value = 100 - validationData.settings.lowValidPercent
            document.querySelector('#HighValidationPercentage').value = 100 - validationData.settings.highValidPercent
            document.querySelector('#lowValidationPercentage').nextElementSibling.value = 100 - validationData.settings.lowValidPercent
            document.querySelector('#HighValidationPercentage').nextElementSibling.value = 100 - validationData.settings.highValidPercent
            // Validation percentage slider listeners
            document.querySelector('#lowValidationPercentage').oninput = function () {
                this.nextElementSibling.value = this.value
                validationData.settings.lowValidPercent = 100 - this.value
                validationData.updateRange()
                updateNode3d();
                updateTotalValidation()
            }
            document.querySelector('#HighValidationPercentage').oninput = function () {
                this.nextElementSibling.value = this.value
                validationData.settings.highValidPercent = 100 - this.value
                validationData.updateRange()
                updateNode3d();
                updateTotalValidation()
            }

            {# add accordion button listeners #}
            let acc = document.querySelectorAll(".accordion");
            for (let i = 0; i < acc.length; i++) {
                toggleAccordion(acc[i])
                acc[i].addEventListener("click", function () {
                    this.classList.toggle("active");
                    toggleAccordion(this);
                });
            }

            function toggleAccordion(accordionBtn) {
                let panel = accordionBtn.nextElementSibling;
                if (accordionBtn.classList.contains("active")) {
                    panel.style.maxHeight = "fit-content";
                    if (panel.style.overflow)
                        panel.style.overflow = "visible";
                } else {
                    panel.style.maxHeight = null;
                    if (panel.style.overflow)
                        panel.style.overflow = 'hidden';
                }
            }

            function openAccordion(accordionBtn) {
                let panel = accordionBtn.nextElementSibling;
                panel.style.maxHeight = "fit-content";
                if (panel.style.overflow)
                    panel.style.overflow = "visible";
            }

            {# navigation panels #}
            let isNavOpen = false; // Sidenav Push Content

            /* Set the width of the side navigation to 250px and the left margin of the page content to 250px */
            function openNav() {
                isNavOpen = true;
                document.getElementById("mySidenav").classList.remove("closeLeftNav");
                document.getElementById("data-table-container").style.marginLeft = "285px";
            }

            /* Set the width of the side navigation to 0 and the left margin of the page content to 0 */
            function closeNav() {
                isNavOpen = false;
                document.getElementById("mySidenav").classList.add("closeLeftNav");
                document.getElementById("data-table-container").style.marginLeft = "0";
            }

            document.querySelector('#optionBtn').onclick = () => { isNavOpen ? closeNav() : openNav(); }

            let isRightNavOpen = false;

            function openRightNav(selectedTab) {
                {# the user know about the panel so no need to open it on 'info' tab for the first time click #}
                isRightNavOpenedBefore = true;

                isRightNavOpen = true;
                document.getElementById("myRightSidenav").classList.remove("closeRightNav");
                document.getElementById("rightTabs").classList.add("tabs-openRightNav");
                document.getElementById("topRightButtons").classList.add("tabs-openRightNav");
                document.getElementById("data-table-container").style.marginRight = "400px";
                switch (selectedTab) {
                    case 'info':
                        document.getElementById('infoBtn').classList.add('selected')
                        document.getElementById('shapeBtn').classList.remove('selected')
                        document.getElementById('validationBtn').classList.remove('selected')

                        // show info menu and hide node check list
                        document.getElementById('infoMenu').classList.remove('disable')
                        document.getElementById('nodeChecklist').classList.add('disable')
                        document.getElementById('validationMenu').classList.add('disable')
                        break;
                    case 'shape':
                        document.getElementById('infoBtn').classList.remove('selected')
                        document.getElementById('shapeBtn').classList.add('selected')
                        document.getElementById('validationBtn').classList.remove('selected')

                        // show node check list and hide info menu
                        document.getElementById('infoMenu').classList.add('disable')
                        document.getElementById('nodeChecklist').classList.remove('disable')
                        document.getElementById('validationMenu').classList.add('disable')
                        break;
                    case 'validation':
                        document.getElementById('infoBtn').classList.remove('selected')
                        document.getElementById('shapeBtn').classList.remove('selected')
                        document.getElementById('validationBtn').classList.add('selected')

                        // show node check list and hide info menu
                        document.getElementById('infoMenu').classList.add('disable')
                        document.getElementById('nodeChecklist').classList.add('disable')
                        document.getElementById('validationMenu').classList.remove('disable')
                        break;
                }
            }

            function closeRightNav() {
                isRightNavOpen = false;
                document.getElementById("myRightSidenav").classList.add("closeRightNav");
                document.getElementById("rightTabs").classList.remove("tabs-openRightNav");
                document.getElementById("topRightButtons").classList.remove("tabs-openRightNav");
                document.getElementById("data-table-container").style.marginRight = "0px";

                document.getElementById('infoBtn').classList.remove('selected')
                document.getElementById('shapeBtn').classList.remove('selected')
                document.getElementById('validationBtn').classList.remove('selected')
            }

            document.querySelector('#infoBtn').onclick = () => {
                if (isRightNavOpen && !document.getElementById("infoBtn").classList.contains("selected")) { openRightNav('info') }
                else if (isRightNavOpen && document.getElementById("infoBtn").classList.contains("selected")) { closeRightNav() }
                else {  openRightNav('info') } // it is closed
            }
            document.querySelector('#shapeBtn').onclick = () => {
                if (isRightNavOpen && !document.getElementById("shapeBtn").classList.contains("selected")) { openRightNav('shape') }
                else if (isRightNavOpen && document.getElementById("shapeBtn").classList.contains("selected")) { closeRightNav() }
                else { openRightNav('shape') } // it is closed
            }
            document.querySelector('#validationBtn').onclick = () => {
                if (isRightNavOpen && !document.getElementById("validationBtn").classList.contains("selected")) { openRightNav('validation') }
                else if (isRightNavOpen && document.getElementById("validationBtn").classList.contains("selected")) { closeRightNav() }
                else { openRightNav('validation') } // it is closed
            }

            let darkMode = true;
            document.querySelector('#darkMode').onclick = () => {
                const checkbox = $("#darkMode").find('input:checkbox:first');
                console.log('darkMode| checkbox.prop(\'checked\')| ' + checkbox.prop('checked'));

                if (darkMode) {
                    checkbox.prop('checked', false);
                    darkMode = false;
                    document.documentElement.setAttribute('data-theme', 'light');
                } else {
                    checkbox.prop('checked', true);
                    darkMode = true;
                    document.documentElement.setAttribute('data-theme', 'dark');
                }

                // update graph
                Graph.backgroundColor(getComputedStyle(document.documentElement).getPropertyValue('--main-background').trim());
                updateNode3d();
            }

            document.querySelector('#requestValidationBtn').onclick = (e) => {
                let shapeNode;
                if (selectedNode.isClass) { shapeNode = selectedNode }
                else { shapeNode = getNodeFromLink(selectedNode.parentLinks[0].source) }

                {# check if the request is sent and abort it#}
                if (requestMap[shapeNode.id]) {
                    delete requestMap[shapeNode.id];
                    requestBtnClicked(false)
                } else {
                    if (requestValidationData(shapeNode))
                        requestBtnClicked(true)
                }
            }

            document.querySelector('#ViewDataBtn').onclick = (e) => {
                {# view selected node data#}
                let html = '<table id="myTable" class="display"><thead><tr>',
                    dataIndex = selectedNode.columns.indexOf('Data');

                selectedNode.columns.forEach(col => { html += '<th>' + col + '</th>' });
                html += '<th>View Data</th></tr></thead><tbody>';

                selectedNode.data.forEach(row => {
                    html += '<tr>';
                    row.forEach(cell => { html += '<td>' + cell + '</td>' });
                    html += '<td><button query-data="' + row[dataIndex] + '" class="btn btn-primary view-data-graph" style="display: block;">View</button></td>';
                    html += '</tr>';
                })

                html += '</tbody></table>';

                document.getElementById('data-table').innerHTML = html;
                $('#myTable').DataTable();

                // button click showDataGraph
                $('#myTable').on('click', '.view-data-graph', function() {
                    showDataGraph(selectedNode, $(this).attr("query-data"));
                    closeDataTable()
                });

                {# show table #}
                showDataTable()
            }

            document.querySelector('#close-table-btn').onclick = () => { closeDataTable() }

            function showDataTable() {
                elem.style.display = "none";
                document.getElementById('data-table-container').style.display = "block";
                Graph.pauseAnimation()
            }

            function closeDataTable() {
                elem.style.display = "block";
                document.getElementById('data-table-container').style.display = "none";
                Graph.resumeAnimation()
            }

            {#validation endpoint box#}
            // getting all required elements
            const endpointWrapper = document.querySelector("#endpointWrapper");
            const endpointInputBox = endpointWrapper.querySelector("#endpointInputBox");
            const endpointSuggBox = endpointWrapper.querySelector("#endpointSuggBox");
            const endpointIcon = endpointWrapper.querySelector("#endpointIcon");
            let endpointLinkTag = endpointWrapper.querySelector("#endpointLinkTag");

            let endpointList = [
                "http://host.docker.internal:9000/sparql",
                "http://127.0.0.1:9000/sparql",
                "http://192.168.111.1:14000/sparql"];
            saveToCacheDefaultValues(endpointInputBox.id, endpointList)

            endpointInputBox.onkeyup = (e) => { endpointSuggest(e.target.value); } // if user presses and releases any key
            endpointInputBox.onfocus = (e) => { endpointSuggest(e.target.value); }
            endpointIcon.onclick = () => { endpointSuggest() }

            function endpointSuggest(userData) {
                let emptyArray = [];
                emptyArray = getFromCache(endpointInputBox.id).filter((data) => {
                    if (userData)
                        // filtering array value and user characters to lowercase and return only those words which are start with user entered chars
                        return data.toLocaleLowerCase().startsWith(userData.toLocaleLowerCase());
                    else
                        return data;
                });
                emptyArray = emptyArray.map((data) => {
                    // passing return data inside li tag
                    return `<li>${data}</li>`;
                });
                endpointWrapper.classList.add("active"); //show autocomplete box
                showEndpointSuggestions(emptyArray.sort());
                let allList = endpointSuggBox.querySelectorAll("li"),
                    clicked = false;
                {# fix on mouse out will hide the highlight after clicking #}
                for (let i = 0; i < allList.length; i++) {
                    // adding onclick attribute in all li tag
                    allList[i].onclick = () => {
                        clicked = true;
                        selectEndpoint(allList[i])
                    };
                }
            }

            let mouse_is_inside_endpoint = false;
            endpointWrapper.onmouseover = () => { mouse_is_inside_endpoint = true; }
            endpointWrapper.onmouseout = () => { mouse_is_inside_endpoint = false; }

            document.querySelector("body").onmouseup = () => {
                if (!mouse_is_inside_endpoint) endpointWrapper.classList.remove("active"); // hide autocomplete box
            }

            function selectEndpoint(element) {
                endpointInputBox.value = element.textContent;
                endpointWrapper.classList.remove("active");
            }

            function showEndpointSuggestions(list) {
                let listData;
                if (!list.length) {
                    let userValue = inputBox.value;
                    listData = `<li>${userValue}</li>`;
                } else {
                    listData = list.join('');
                }
                endpointSuggBox.innerHTML = listData;
            }

            // save cache list to local storage
            function saveToCache(id, value) {
                let json = localStorage.getItem(id),
                    array;
                if (json != null) {
                    array = JSON.parse(json);
                    let set = new Set(array).add(value); // no duplicates
                    array = Array.from(set)
                } else {
                    array = [value]
                }
                let json2 = JSON.stringify(array);
                localStorage.setItem(id, json2)
            }

            function saveToCacheDefaultValues(id, array) {
                let json = localStorage.getItem(id);
                if (json == null) {
                    json = JSON.stringify(array);
                    localStorage.setItem(id, json)
                }
            }

            function getFromCache(id) {
                let c = localStorage.getItem(id);
                if (c != null)
                    return Array.from(JSON.parse(c))
                else
                    return []
            }

            {# Data viewer #}
            function showShapeGraph() {
                {# restore #}
                nodes.length = 0;
                links.length = 0;
                nodes.push(...backupNodes);
                links.push(...backupLinks);
                selectedNode = bachupSelectedNode;
                {# empty backup data #}
                backupNodes.length = 0;
                backupLinks.length = 0;
                bachupSelectedNode = null;

                isShowingDataGraph = false;
                resetGraphMaps();
                resetShapeCheckList();
                updateGraph();
                viewNodeInfo(selectedNode);
                fillValidationData();
            }

            function showDataGraph(shape, id) {
                loading(true);
                requestDataNode(shape, id, function (json) {
                    // show data graph
                    let graph = creatDataNetwork(shape, id, json);
                    {# backup #}
                    backupNodes.length = 0;
                    backupLinks.length = 0;
                    backupNodes.push(...nodes);
                    backupLinks.push(...links);
                    bachupSelectedNode = selectedNode;
                    {# show #}
                    nodes.length = 0;
                    links.length = 0;
                    nodes.push(graph.main);
                    nodes.push(...graph.nodes);
                    links.push(...graph.links);
                    selectedNode = graph.main;

                    isShowingDataGraph = true;
                    resetGraphMaps(true);
                    resetShapeCheckList();
                    updateGraph();

                    viewNodeInfo(selectedNode);
                    highlightNode(selectedNode);
                    openRightNav('info');
                    document.getElementById('validationBtn').style.display = "none";
                    document.getElementById('topRightButtons').style.display = "flex";

                    loading(false);
                }, function () { loading(false) })
            }

            function requestDataNode(shape, id, callbackSuccess, callbackFail) {
                let endpoint = endpointInputBox.value,
                    query = getQueryString(shape, id);
                $.ajax({
                    dataType: "jsonp",
                    url: endpoint + "?query=" + encodeURIComponent(query) + "&format=json",
                    success: function (json, textStatus, jqXHR) {
                        console.log("Show Data Graph request success")
                        console.log(json)
                        console.log(textStatus)
                        console.log(jqXHR)
                        callbackSuccess(json)
                    },
                    error: function (jqXHR, exception) {
                        console.log("Show Data Graph request error:")
                        console.log(jqXHR.status)
                        console.log(exception)
                        let msg = '';
                        if (jqXHR.status === 0) {
                            msg = ': Cannot connect to shaclAPI';
                        } else if (jqXHR.status === 404) {
                            msg = ': Requested page not found. [404]';
                        } else if (jqXHR.status === 500) {
                            msg = ': Internal Server Error [500].';
                        } else if (exception === 'parsererror') {
                            msg = ': Requested JSON parse failed.';
                        } else if (exception === 'timeout') {
                            msg = ': Time out error.';
                        } else if (exception === 'abort') {
                            msg = ': Ajax request aborted.';
                        } else {
                            msg = ': Uncaught Error.\n' + jqXHR.responseText;
                        }
                        $('#flash').append(flashMessage(msg, 'warning'));
                        callbackFail();
                    }
                });
            }

            function getQueryString(shape, data) {
                let query = 'SELECT DISTINCT ?p ?o WHERE { VALUES ?p {',
                    prefix = shape.prefix.slice(0, -1); ///remove '>'

                shape.childLinks.forEach(link => {
                    if (link.linkType === 1 || link.linkType === 3) {
                        let constraint = getNodeFromLink(link.target);
                        query += prefix + constraint.text + '> '
                    }
                })

                query += '} OPTIONAL {<' + data + '>?p ?o }}'

                console.log('getQueryString')
                console.log(query)
                return query
            }

            function creatDataNetwork(shape, id, json) {
                {# clear data graph #}
                let dataGraphNodeList = [],
                    dataGraphLinkList = [],
                    constraintMap = buildConstraintsMap(shape), {# to search for constraints #}
                    dataNode = createDataNode(id, shape, true),
                    jsonConstraintsList = json.results.bindings,
                    i = 0;
                jsonConstraintsList.forEach(obj => {
                    i += 1

                    if (typeof obj.o == 'undefined') {
                        console.log('creatDataNetwork| Empty: ' + obj.p.value)
                        return;
                    }

                    let constraintString = obj.p.value.split('#').pop(),
                        constraintValue = obj.o.value,
                        currentShapeConstraint = constraintMap.get(constraintString);

                    if (currentShapeConstraint.isAttribute) {
                        // create Attribute Node and link it using one link
                        let attribute = createAttributeNode(i, currentShapeConstraint, dataNode, constraintValue, currentShapeConstraint.min, currentShapeConstraint.max),
                            link = createLink(i, constraintString, dataNode, attribute, 1, currentShapeConstraint.min, currentShapeConstraint.max);
                        dataGraphNodeList.push(attribute);
                        dataGraphLinkList.push(link)
                    }

                    if (!currentShapeConstraint.isAttribute) {
                        // create Constraint Node and Data Node then link them with 3 links
                        let n = getNodeFromLink(currentShapeConstraint.childLinks[0].target),
                            nextDataNode = createDataNode(constraintValue, n, false),
                            constraint = createConstraintNode(i, currentShapeConstraint, dataNode, constraintString, currentShapeConstraint.min, currentShapeConstraint.max),
                            link0 = createLink(i, constraintString, dataNode, nextDataNode, 0, currentShapeConstraint.min, currentShapeConstraint.max),
                            link3 = createLink(i, constraintString, dataNode, constraint, 3, currentShapeConstraint.min, currentShapeConstraint.max),
                            link4 = createLink(i, constraintString, constraint, nextDataNode, 4, currentShapeConstraint.min, currentShapeConstraint.max);
                        link3.finalTarget = nextDataNode.id;
                        dataGraphNodeList.push(constraint, nextDataNode);
                        dataGraphLinkList.push(link0, link3, link4)
                    }
                })
                return {main: dataNode, nodes: dataGraphNodeList, links: dataGraphLinkList}
            }

            {# create data node "almost as shape node" #}
            function createDataNode(id, shape, retrieved) {
                let node = nodesById[id]
                if (node)
                    return node
                else {
                    node = {
                        id: id,
                        group: id,
                        text: id.split('/').pop(),
                        isClass: true,
                        expanded: false,
                        isHidden: false,
                        highlighted: false,
                        childLinks: [],
                        parentLinks: [],
                        query: shape.query,
                        prefix: shape.prefix,
                        targetDef: shape.targetDef,
                        valid: -1,
                        invalid: -1,
                        columns: [],
                        data: [],
                        colorRange: 0 {# 0:unvalidated, 1:allValid, 2:low, 3:medium, 4:high, 5:validating #}
                    }
                    node.shape = shape
                    node.retrieved = retrieved
                    return node;
                }
            }

            function createAttributeNode(incremental, constraint, dataNode, name, min, max) {
                let node = {
                    id: incremental + '|' + dataNode.id + ',' + name,
                    group: dataNode.id,
                    text: name,
                    min: min,
                    max: max,
                    isClass: false,
                    expanded: true,
                    isHidden: false,
                    highlighted: false,
                    childLinks: [],
                    parentLinks: [],
                    isAttribute: true
                }
                node.constraint = constraint
                return node
            }

            function createConstraintNode(incremental, constraint, dataNode, name, min, max) {
                let node = {
                    id: incremental + '|' + dataNode.id + ',' + name,
                    group: dataNode.id,
                    text: name,
                    min: min,
                    max: max,
                    isClass: false,
                    expanded: true,
                    isHidden: false,
                    highlighted: false,
                    childLinks: [],
                    parentLinks: [],
                    isAttribute: false
                }
                node.constraint = constraint
                return node
            }

            {# linkType:
               0: class to class
               1: class to attribute
               2: attribute to same class
               3: class to constraint
               4: constraint to other class
             #}
            function createLink(incremental, text, from, to, type, min, max) {

                let link = {
                    id: incremental + '|' + type + '|from:' + from.id + ',to:' + to.id,
                    source: from.id,
                    target: to.id,
                    text: text,
                    min: min,
                    max: max,
                    isHidden: false,
                    highlighted: false,
                    length: getLinkLength(type),
                    linkType: type
                }

                switch (type) {
                    case 0:
                        link.isClass2Class = true
                        link.collapsed = false
                        link.isAttribute = false
                        break;
                    case 1:
                        link.isClass2Class = false
                        link.collapsed = true
                        link.isAttribute = true
                        break;
                    case 3:
                        link.isClass2Class = false
                        link.collapsed = true
                        link.isAttribute = false
                        break;
                    case 4:
                        link.isClass2Class = false
                        link.collapsed = true
                        link.isAttribute = false
                        break;
                    default:
                        return 1
                }
                return link;
            }

            function buildConstraintsMap(shape) {
                let res = new Map()
                shape.childLinks.forEach(link => {
                    if (link.linkType === 1 || link.linkType === 3) {
                        let constraint = getNodeFromLink(link.target);
                        res.set(constraint.text, constraint)
                    }
                })
                return res
            }

            function updateDataGraph(node, callback) {
                loading(true);
                requestDataNode(node.shape, node.id, function (json) { // update node in the data graph and add its constraints
                    // create data graph
                    let graph = creatDataNetwork(node.shape, node.id, json)

                    node.retrieved = true
                    nodes.push(...graph.nodes)
                    links.push(...graph.links)

                    resetGraphMaps(true)
                    resetShapeCheckList()
                    updateGraph()

                    loading(false)

                    callback()
                }, function () {
                    loading(false)
                })
            }

            document.querySelector('#closeDataGraph').onclick = () => {
                document.getElementById('topRightButtons').style.display = "none"
                document.getElementById('validationBtn').style.display = "block"
                openRightNav('validation')
                showDataTable()
                showShapeGraph()
            }

            /** TODO
             *
             * infoTree combine similar constraints when isShowDataGraph
             * infoTree text icon for data text
             *
             */
            function loading(startLoading) {
                if (startLoading)
                    document.querySelector('#loader').classList.add("loader");
                else
                    document.querySelector('#loader').removeAttribute("class");
            }

            {# remove loader #}
            document.querySelector('#loader').removeAttribute("class");
        </script>
    </div>
{% endblock %}
