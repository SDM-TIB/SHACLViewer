{% include 'basemain.html' %}
{% block headbase %}

    <link rel="stylesheet" href="./static/css/basegraph.css">
    <link rel="stylesheet" href="./static/css/jquery.dataTables.min.css">

    <style> body {
        margin: 0;
    } </style>

    {#    <script src="//unpkg.com/three"></script>#}
    {#    <script src="//unpkg.com/three/examples/js/renderers/CSS2DRenderer.js"></script>#}
    {#    <script src="//unpkg.com/three-spritetext"></script>#}
    <script src="./static/js/three/three.js"></script>
    <script src="./static/js/three/CSS2DRenderer.js"></script>
    <script src="./static/js/sprite/three-spritetext.js"></script>
    <script src="./static/js/dataTable/jquery.dataTables.min.js"></script>

    {#    <link rel="stylesheet" type="text/css" href="https://cdn.datatables.net/1.12.1/css/jquery.dataTables.css">#}
    {#    <script type="text/javascript" charset="utf8"#}
    {#            src="https://cdn.datatables.net/1.12.1/js/jquery.dataTables.js"></script>#}


    {% block head %}{% endblock %}

{% endblock %}

{#{% block title %}#}
<title>{{ request.args.get("path") }} Graph</title>
{#{% endblock %}#}

{% block body %}

    <span id="optionBtn" class="option-btn">&#9776; Options</span>
    <div id="mySidenav" class="sidenav leftnav closeLeftNav">
        <div class="wrapper">
            <div id="search-wrapper" class="search-input">
                <a id="search-linkTag" href="" target="_blank" hidden></a>
                <input id="search-input" type="text" placeholder="Search for Shape..">
                <div id="search-sugg" class="autocom-box">
                </div>
                <div id="search-icon" class="icon"><i class="fas fa-search"></i></div>
            </div>
        </div>
        <a href="javascript:void(0)" id="hideUnrelatedClasses"><i class=''></i>Show Selected Shape Only
            <label class="switch">
                <input type="checkbox" disabled="disabled">
                <span class="slider round"></span>
            </label>
        </a>
        <a href="javascript:void(0)" id="highlightSelectedNode"><i class=''></i>Highlight Selected
            <label class="switch">
                <input type="checkbox" disabled="disabled" checked="true">
                <span class="slider round"></span>
            </label>
        </a>
        <a href="javascript:void(0)" id="focusNode"><i class="fas fa-crosshairs option-icon"></i> Focus Selected
            Shape</a>
        <a href="javascript:void(0)" id="centerGraph"><i class="fas fa-expand option-icon"></i> Center Graph</a>
        <a href="javascript:void(0)" id="expandAll"><i class="fa fa-expand-arrows-alt option-icon"
                                                       aria-hidden="true"></i>
            Expand All</a>
        <a href="javascript:void(0)" id="collapseAll"><i class='fas fa-compress-arrows-alt option-icon'></i> Collapse
            All</a>
        <a href="javascript:void(0)" id="hideAttributes"><i class=''></i>Hide Intra-Constraints
            <label class="switch">
                <input type="checkbox" disabled="disabled">
                <span class="slider round"></span>
            </label>
        </a>
        <button class="accordion">Links Length</button>
        <div class="slider-container panel">
            <p>Shape to Shape link</p>
            <input type="range" class="range-style" id="class2classLinkSlider" min="0" max="200">
            <output>150</output>
            <p>Shape to Intra-Constraint link</p>
            <input type="range" class="range-style" id="attributeLinkSlider" min="0" max="200">
            <output>150</output>
            <p>Shape to Inter-Constraint link</p>
            <input type="range" class="range-style" id="toConstraintLinkSlider" min="0" max="200">
            <output>150</output>
            <p>Inter-Constraint to Shape link</p>
            <input type="range" class="range-style" id="fromConstraintLinkSlider" min="0" max="200">
            <output>150</output>
        </div>
        <button class="accordion">Validation Intensity Categorization</button>
        <div class="slider-container panel">
            <p>Low Invalid Percentage</p>
            <input type="range" class="range-style" id="lowValidationPercentage" min="0" max="100">
            <output>60</output>
            <p>High Invalid Percentage</p>
            <input type="range" class="range-style" id="HighValidationPercentage" min="0" max="100">
            <output>90</output>
        </div>
        {#<a href="javascript:void(0)" id="dataGraph"><i class='fas fa-compress-arrows-alt option-icon'></i> Data
            Graph</a>#}
    </div>
    <div id="rightButtons" style="display: none;">
        <button id="closeDataGraph" class="btn btn-block btn-right-nav btn-primary"
                style="display: block;max-width: 180px;margin-right: 52px;">Back to Data Table
        </button>
    </div>
    <div id="rightTabs">
        <span id="infoBtn" class="right-tab-btn">Info</span>
        <span id="shapeBtn" class="right-tab-btn">Shapes</span>
        <span id="validationBtn" class="right-tab-btn">Validation</span>
    </div>
    <div id="myRightSidenav" class="sidenav rightnav closeRightNav">
        <div id="infoMenu">
            <button class="accordion active">Meta Data</button>
            <div class="slider-container panel">
                <div id="infoStatistic"></div>
            </div>
            <button class="accordion active">Constraints</button>
            <div class="slider-container panel">
                <div id="infoTree"></div>
            </div>
        </div>
        <div id="nodeChecklist">
            <ul></ul>
        </div>
        <div id="validationMenu">
            <button id="ValidationEndpointAccordion" class="accordion active">Validation Endpoint</button>
            <div id="validationEndpointWrapper" class="wrapper slider-container panel"
                 style="overflow: visible;">
                <div style="padding: 10px 0px;">
                    <div id="endpointWrapper" class="search-input">
                        <a id="endpointLinkTag" href="" target="_blank" hidden></a>
                        <input id="endpointInputBox" type="text" placeholder="Endpoint Address..">
                        <div id="endpointSuggBox" class="autocom-box">
                        </div>
                        <div id="endpointIcon" class="icon"><i class="fas fa-angle-down"></i></div>
                    </div>
                </div>
            </div>
            {#<div class="slider-container panel">
                <select id="validationEndpointDropdown">
                    <option selected="selected" value="http://192.168.111.1:14000/sparql">
                        http://192.168.111.1:14000/sparql
                    </option>
                    <option value="https://labs.tib.eu/sdm/clarify-kg-7/sparql">
                        https://labs.tib.eu/sdm/clarify-kg-7/sparql
                    </option>
                </select>
                <input id="validationEndpointTextBox"/>
            </div>#}
            <button class="accordion active">Total Validation Data</button>
            <div class="slider-container panel">
                <div id="totalValidationData"></div>
            </div>
            <button class="accordion active">Selected Shape Data</button>
            <div class="slider-container panel">
                <div id="selectedValidationRequest">
                    <button id="requestValidationBtn" class="btn btn-primary btn-block btn-right-nav"
                            style="display:none;">Request
                        Validation
                    </button>
                </div>
                <div id="selectedValidationData"></div>
                <button id="ViewDataBtn" class="btn btn-primary btn-block btn-right-nav" style="display:none;">View
                    Data
                </button>
            </div>
        </div>
        {#        {% block infoMenu %}#}
        {#        #}
        {#        {% endblock %}#}
    </div>
    <div id="main">
        <div id="3d-graph" style="position: absolute;top: 0;"></div>
        <div id="data-table-container"
             style="display: none; padding: 0px 60px 15px 15px; transition: margin 0.5s ease 0s;">
            <button id="close-table-btn" class="btn btn-primary btn-block"
                    style="display: block;max-width: 96px;right: 0;float: right;margin: 10px 0px;">Close
            </button>
            <div id="data-table"></div>
        </div>
        <div id="loader" class="loader"></div>
        <script type="module">
            {#$('#flash').append(flashMessage('graph size => {{ graph|length }}', 'info'));#}
            {#console.log({{ graph }})#}

            const nodes = [];
            const GROUPS = 1;
            const links = [];
            const none = 'None'
            {#let local_links_count = 0;#}
            let currentNode;
            let selectedNode;

            {# used for data graph #}
            const backupNodes = []
            const backupLinks = []
            let bachupSelectedNode;
            let isShowingDataGraph = false

            {#
            linkType:
             0: class to class
             1: class to attribute
             2: attribute to same class
             3: class to constraint
             4: constraint to other class
             #}

            {% for node in graph %}
                {# add class/shape node #}
                currentNode = {
                    id: '{{ node.id }}',
                    group: '{{ node.id }}',
                    text: '{{ node.id }}',
                    isClass: true,
                    expanded: false,
                    isHidden: false,
                    highlighted: false,
                    childLinks: [],
                    parentLinks: [],
                    query: '{{ node.targetQuery|safe }}',
                    prefix: '{{ node.prefixes['ub']|safe }}',
                    targetDef: '{{ node.targetDef }}',
                    valid: -1,
                    invalid: -1,
                    columns: [],
                    data: [],
                    colorRange: 0 {# 0:unvalidated, 1:allValid, 2:low, 3:medium, 4:high, 5:validating #}
                }
                nodes.push(currentNode);

                {% set same_curv = namespace(value=20) %}
                {% set same_rot = namespace(value=0) %}
                {% set link_count = namespace(value=-1) %}
                {% set curv = namespace(value=0) %}
                {% set rot = namespace(value=0) %}
                {% for link in node.get_constraints() %}


                    {% set link_node_name = link.path %}
                    {# set constraint node name with min and max to fix unlinked nodes#}
                    {#                {% if none != link.min %}#}
                    {#                    {% set link_node_name = link_node_name ~ ' > ' ~ link.min %}#}
                    {#                {% endif %}#}
                    {#                {% if none != link.max %}#}
                    {#                    {% set link_node_name = link_node_name ~ ' < ' ~ link.max %}#}
                    {#                {% endif %}#}


                    {% set link_count.value = link_count.value + 1 %}

                    {% if none == link.shapeRef %}
                        {# link goes to the same node #}
                        {% set same_curv.value = same_curv.value + 2 %}
                        {% set same_rot.value = same_rot.value + 2 %}
                        {#local_links_count++; {# debug #}
                        {# add constraint as node #}
                        nodes.push({
                            id: '{{ node.id }},{{ link_count.value }}-{{ link.path }}',
                            group: '{{ node.id }}',
                            text: '{{ link_node_name }}',
                            min: '{{ link.min }}',
                            max: '{{ link.max }}',
                            isClass: false,
                            expanded: true,
                            isHidden: false,
                            highlighted: false,
                            childLinks: [],
                            parentLinks: [],
                            isAttribute: true
                        });
                        links.push({
                            id: '1|linkOutToConstraint,{{ node.id }},{{ link_count.value }}-{{ link.path }}',
                            source: '{{ node.id }}',
                            target: '{{ node.id }},{{ link_count.value }}-{{ link.path }}',
                            text: '{{ link_node_name }}',
                            min: '{{ link.min }}',
                            max: '{{ link.max }}',
                            isClass2Class: false,
                            collapsed: true,
                            isHidden: false,
                            highlighted: false,
                            {#particles: 2,#}
                            {#curvature: {{ same_curv.value/100 }},#}
                            {#rotation:{{ same_rot.value/10 }},#}
                            length: 25,
                            isAttribute: true,
                            linkType: 1
                        });
                        {#links.push({
                            id:'linkBackFromConstraint,{{ node.id }},{{ link_count.value }}-{{ link.path }}',
                            source: '{{ node.id }},{{ link_count.value }}-{{ link.path }}',
                            target: '{{ node.id }}',
                            text: '{{ link_node_name }}',
                            isClass2Class: false,
                            collapsed: true,
                            isHidden: false,
                            highlighted: false,
                            particles: 2,
                            curvature: {{ same_curv.value/100 }},
                            rotation:{{ same_rot.value/10 }},
                            length: 25,
                            isAttribute: true,
                            linkType:2
                        })#}
                    {% else %}
                        {# link goes to another node #}
                        links.push({
                            id: '0|{{ link_count.value }}.linkClass:{{ node.id }},toClass:{{ link.shapeRef }}',
                            source: '{{ node.id }}',
                            target: '{{ link.shapeRef }}',
                            text: '{{ link_node_name }}',
                            min: '{{ link.min }}',
                            max: '{{ link.max }}',
                            isClass2Class: true,
                            collapsed: false,
                            isHidden: false,
                            highlighted: false,
                            particles: 0,
                            {#curvature: {{ curv.value/10 }},#}
                            curvature: 0.2,
                            rotation:{{ rot.value/10 }},
                            length: 100,
                            {#rotation:0#}
                            isAttribute: false,
                            linkType: 0
                        })

                        {# add a constraint as a node and connect it both classes #}
                        nodes.push({
                            id: '{{ node.id }},{{ link_count.value }}-{{ link.path }}',
                            group: '{{ node.id }}',
                            text: '{{ link_node_name }}',
                            min: '{{ link.min }}',
                            max: '{{ link.max }}',
                            isClass: false,
                            expanded: true,
                            isHidden: false,
                            highlighted: false,
                            childLinks: [],
                            parentLinks: [],
                            isAttribute: false
                        });
                        links.push({
                            id: '3|linkToConstraintFrom,{{ node.id }},To,{{ node.id }},{{ link_count.value }}-{{ link.path }}',
                            source: '{{ node.id }}',
                            target: '{{ node.id }},{{ link_count.value }}-{{ link.path }}',
                            finalTarget: '{{ link.shapeRef }}',
                            text: '{{ link_node_name }}',
                            min: '{{ link.min }}',
                            max: '{{ link.max }}',
                            isClass2Class: false,
                            collapsed: true,
                            isHidden: false,
                            highlighted: false,
                            particles: 2,
                            {#curvature: {{ curv.value/10 }},#}
                            {#curvature: 0.2,#}
                            {#rotation:{{ rot.value/10 }},#}
                            length: 25,
                            {#rotation:0#}
                            isAttribute: false,
                            linkType: 3
                        })
                        links.push({
                            id: '4|linkFromConstraint,{{ node.id }},{{ link_count.value }}-{{ link.path }},To,{{ link.shapeRef }}',
                            source: '{{ node.id }},{{ link_count.value }}-{{ link.path }}',
                            target: '{{ link.shapeRef }}',
                            text: '{{ link_node_name }}',
                            min: '{{ link.min }}',
                            max: '{{ link.max }}',
                            isClass2Class: false,
                            collapsed: true,
                            isHidden: false,
                            highlighted: false,
                            particles: 2,
                            {#curvature: {{ curv.value/10 }},#}
                            {#curvature: 0.2,#}
                            {#rotation:{{ rot.value/10 }},#}
                            length: 50,
                            {#rotation:0#}
                            isAttribute: false,
                            linkType: 4
                        })
                        {% set curv.value = curv.value + 1 %}
                        {% set rot.value = rot.value + 12 %}
                    {% endif %}

                    {#   shapeRef = '{{ link.shapeRef }}'
                       #}{#console.log(`link.shapeRef= ${shapeRef}`)#}{#
                       if (shapeRef.localeCompare('None') != 0) {
                           #}{#console.log(`True`)#}{#
                           links.push({
                               source: '{{ node.id }}',
                               target: shapeRef
                           })
                       } else
                           local_links_count++;
                       links.push({
                           source: '{{ node.id }}',
                           target: '{{ node.id }}'
                       })
                       #}{#console.log(`false`)#}{#
                       #}

                {% endfor %}
            {% endfor %}

            class Statistics {
                attributes = 0;
                constraints = 0;
                partOff = 0;

                constructor() {
                }
            }

            const nodesById = {}
            const linksById = {}
            resetGraphMaps()

            function resetGraphMaps(removeDuplicates) {
                {# clear #}
                Object.keys(nodesById).forEach(key => delete nodesById[key]);
                Object.keys(linksById).forEach(key => delete linksById[key]);
                {# refill #}
                Object.assign(nodesById, Object.fromEntries(nodes.map(node => [node.id, node])));
                Object.assign(linksById, Object.fromEntries(links.map(link => [link.id, link])));

                if (removeDuplicates) {
                    nodes.length = 0
                    nodes.push(...Object.values(nodesById))
                }

                {# clear node lists #}
                nodes.forEach(n => {
                    n.childLinks = []
                    n.parentLinks = []
                })
                {# fill nodes' lists #}
                links.forEach(link => {
                    let source = nodesById[link.source]
                    getNodeFromLink(link.source).childLinks.push(link);
                    getNodeFromLink(link.target).parentLinks.push(link);
                });
                nodes.forEach(node => {
                    const stat = new Statistics();
                    node.childLinks.forEach(link => {
                        if (link.isClass2Class)
                            stat.constraints++;
                        else if (link.isAttribute)
                            stat.attributes++;
                    })
                    node.parentLinks.forEach(link => {
                        if (link.isClass2Class)
                            stat.partOff++;
                    })
                    node.statistics = stat;
                })
            }

            function updateClassState(node) {
                {#updateNode3d(node)#}

                {# foreach link to this node show/hide the links to classes and hide/show links to constraint and their links #}
                node.childLinks.forEach(link => {
                    {#link.isHidden = false; {# by default show all links that's been hidden by other functions #}

                    if (link.isClass2Class) {
                        {# if node not expanded => show link to other classes #}
                        link.collapsed = node.expanded;

                        if (hideUnrelatedClasses) {
                            link.isHidden = false;
                        }
                    } else {  {# links to constraint #}
                        link.collapsed = !node.expanded;
                        let constraint = getNodeFromLink(link.target);
                        constraint.expanded = !node.expanded;
                        if (!constraint.isClass){# so when clicking on constraint it wont highlight all links of the target node #}
                            constraint.childLinks.forEach(l => {
                                l.collapsed = !node.expanded

                                if (hideUnrelatedClasses) { {# show links and constraints of clicked nodes because now they are related #}
                                    l.isHidden = false;
                                    let target = getNodeFromLink(l.target);
                                    target.isHidden = false;

                                    target.childLinks.forEach(cl => { {# show links to already shown nodes #}
                                        if (cl.isClass2Class) {
                                            cl.isHidden = getNodeFromLink(cl.target).isHidden
                                        }
                                    });
                                    target.parentLinks.forEach(cl => { {# show links to already shown nodes #}
                                        if (cl.isClass2Class) {
                                            cl.isHidden = getNodeFromLink(cl.source).isHidden
                                        }
                                    });
                                }
                            });

                        if (hideUnrelatedClasses) { {# show links and constraints of clicked nodes because now they are related #}
                            link.isHidden = false;
                            constraint.isHidden = false;
                        }

                        {#if (hideAttributes && link.isAttribute) {
                            link.isHidden = true;
                            constraint.isHidden = true;
                        }#}
                    }
                })

                updateGraph();
            };

            function getNodeFromLink(linkTarget) {
                {# before drawing for the first time the link.target is just a string, after that it will be an object #}
                if ((typeof linkTarget) === 'object') {
                    return linkTarget
                } else {
                    let res = nodesById[linkTarget]
                    if ((typeof res) === 'object')
                        return nodesById[linkTarget]
                    else {
                        {# manual search because getNodeFromLink didn't work on the current nodesById map #}
                        for (let i = 0; i < backupNodes.length; i++) {
                            if (backupNodes[i].id == linkTarget)
                                return backupNodes[i];
                        }
                    }
                }
            }

            function highlightNode(node) {
                if (highlightSelectedNode) {
                    nodes.forEach(n => n.highlighted = false)
                    links.forEach(l => l.highlighted = false)
                    node.highlighted = true;
                    if (node.isClass) {
                        node.childLinks.forEach(link => {
                            link.highlighted = true;
                            if (!link.isClass2Class) {
                                let constraintNode = getNodeFromLink(link.target);
                                constraintNode.highlighted = true;
                                constraintNode.childLinks.forEach(l => l.highlighted = true)
                            }
                        })
                    } else {
                        node.childLinks.forEach(link => link.highlighted = true);
                        node.parentLinks.forEach(link => link.highlighted = true);
                    }

                    updateNode3d()
                }
            }

            let hideAttributes = false;

            function updateGraph() {
                Graph.graphData(getVisibleLists())
            }

            function getVisibleLists() {
                const visibleNodes = [];
                const visibleLinks = [];

                let enableUpdate = false;

                if (document.getElementById('nodeChecklist').getElementsByTagName('ul')[0].innerHTML != "")
                    enableUpdate = true;

                nodes.forEach(node => {
                    // check hideAttributes feature
                    if (!node.isAttribute || (node.isAttribute && !hideAttributes))
                        if (!node.isHidden)
                            if (!node.expanded || node.isClass)
                                visibleNodes.push(node)

                    // update check list
                    if (enableUpdate && node.isClass)
                        if (node.isHidden)
                            shapeCheckList[node.id].classList.remove('checked');
                        else
                            shapeCheckList[node.id].classList.add('checked');
                });
                links.forEach(link => {
                    // check hideAttributes feature
                    if (!link.isAttribute || (link.isAttribute && !hideAttributes))
                        if (!link.isHidden && !link.collapsed)
                            visibleLinks.push(link)
                });

                updateNode3d();
                return {nodes: visibleNodes, links: visibleLinks};
            }

            function debugNode(node) {
                console.log('debugNode|')
                console.log(node)
                {#console.log(JSON.stringify(node.id))#}
                {#console.log(links.filter(link => link.source.id === node.id || link.target.id === node.id));#}
            }

            function debugLink(link) {
                {#return nodes.filter(node => node.id === link.source.id || node.id === link.target.id);#}
                console.log('debugLink|')
                console.log(link)
                {#console.log('source: ' + link.source)#}
                {#console.log('target: ' + link.target)#}
            }

            {#        function getNodeShape(node, parameters) {
                        if (parameters === undefined) parameters = {};
                        var fontface = parameters.hasOwnProperty("fontface") ? parameters["fontface"] : "Arial";
                        var fontsize = parameters.hasOwnProperty("fontsize") ? parameters["fontsize"] : 58;
                        var borderThickness = parameters.hasOwnProperty("borderThickness") ? parameters["borderThickness"] : 4;
                        var borderColor = parameters.hasOwnProperty("borderColor") ? parameters["borderColor"] : {
                            r: 255,
                            g: 0,
                            b: 0,
                            a: 1.0
                        };
                        var backgroundColor = parameters.hasOwnProperty("backgroundColor") ? parameters["backgroundColor"] : {
                            r: 255,
                            g: 255,
                            b: 255,
                            a: 1.0
                        };
                        var textColor = parameters.hasOwnProperty("textColor") ? parameters["textColor"] : {
                            r: 0,
                            g: 0,
                            b: 0,
                            a: 1.0
                        };

                        var canvas = document.createElement('canvas');
                        var context = canvas.getContext('2d');
                        context.font = "Bold " + fontsize + "px " + fontface;
                        var metrics = context.measureText(node.text);
                        var textWidth = metrics.width;

                        context.fillStyle = "rgba(" + backgroundColor.r + "," + backgroundColor.g + "," + backgroundColor.b + "," + backgroundColor.a + ")";
                        context.strokeStyle = "rgba(" + borderColor.r + "," + borderColor.g + "," + borderColor.b + "," + borderColor.a + ")";

                        context.lineWidth = borderThickness;
                        roundRect(context, borderThickness / 2, borderThickness / 2, (textWidth + borderThickness) * 1.1, fontsize * 1.4 + borderThickness, 8);

                        context.fillStyle = "rgba(" + textColor.r + ", " + textColor.g + ", " + textColor.b + ", 1.0)";
                        context.fillText(node.text, borderThickness, fontsize + borderThickness);

                        var texture = new THREE.Texture(canvas)
                        texture.needsUpdate = true;

                        var spriteMaterial = new THREE.SpriteMaterial({map: texture, useScreenCoordinates: false});
                        var sprite = new THREE.Sprite(spriteMaterial);
                        sprite.scale.set(0.5 * fontsize, 0.25 * fontsize, 0.75 * fontsize);
                        return sprite;
                    }

                    function roundRect(ctx, x, y, w, h, r) {
                        ctx.beginPath();
                        ctx.moveTo(x + r, y);
                        ctx.lineTo(x + w - r, y);
                        ctx.quadraticCurveTo(x + w, y, x + w, y + r);
                        ctx.lineTo(x + w, y + h - r);
                        ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
                        ctx.lineTo(x + r, y + h);
                        ctx.quadraticCurveTo(x, y + h, x, y + h - r);
                        ctx.lineTo(x, y + r);
                        ctx.quadraticCurveTo(x, y, x + r, y);
                        ctx.closePath();
                        ctx.fill();
                        ctx.stroke();
                    }#}

            {# debug #}
            {#$('#flash').append(flashMessage(`Shapes= {{ graph|length }} | Nodes= ${nodes.length} | Links= ${links.length}`, 'info'));#}
            {#console.log(JSON.stringify(nodes))#}
            {#console.log(JSON.stringify(links))#}


            {% block graph_implementation %}

            {% endblock %}

            // link length
            const linkForce =
                Graph.d3Force('link').distance(link => getLinkLength(link.linkType));

            function getLinkLength(linkType) {
                switch (linkType) {
                    case 0:
                        return settings.linkLengthClass2Class
                    case 1:
                        return settings.linkLengthAttribute
                    case 3:
                        return settings.linkLengthToConstraint
                    case 4:
                        return settings.linkLengthFromConstraint
                    default:
                        return 1
                }
            }

            let isRightNavOpenedBefore = false

            function onNodeClicked(node) {
                {#debug#}
                {#console.log('onNodeClick|')#}
                {#debugNode(node)#}

                {# if shoding data grapn and the node is not retrieved #}
                if (isShowingDataGraph && node.isClass && !node.retrieved) {
                    {# get the shape data and recall this function #}
                    updateDataGraph(node, function () {
                        onNodeClicked(node)
                    })
                    return
                }

                if (node === selectedNode && node.isClass) {
                    node.expanded = !node.expanded; // toggle collapse state
                    console.log('if node.isClass| ' + node.id + '.expanded ' + node.expanded)
                    updateClassState(node);
                }

                {# show all edges on node focus that was been hidden #}
                if (hideUnrelatedClasses) {
                    console.log("onNodeClicked | hideUnrelatedClasses | show all edges")
                    node.childLinks.forEach(link => {
                        if (node.expanded) {
                            if (link.linkType == 3) {
                                link.isHidden = false;
                                getNodeFromLink(link.target).isHidden = false;
                                getNodeFromLink(link.finalTarget).isHidden = false;
                            }
                        } else {
                            if (link.linkType == 0) {
                                link.isHidden = false;
                                getNodeFromLink(link.target).isHidden = false;
                            }
                        }
                    })
                    updateHiddenLinks();
                    {# to show links between the new shown classes #}
                    updateGraph();
                }

                // open info panel for the first time
                if (!isRightNavOpenedBefore) {
                    openRightNav('info');
                    isRightNavOpenedBefore = true;
                }

                viewNodeInfo(node)
                fillValidationData()
                highlightNode(node)
            }

            // Info navigation
            {#import {BootstrapTreeView} from 'https://unpkg.com/simple-treeview/dist/treeview.bootstrap.js';#}

            import {BootstrapTreeView} from './static/js/treeview/treeview.bootstrap.js';

            {# fill info menu #}

            function viewNodeInfo(node) {

                // fill statistics
                let stat = document.getElementById('infoStatistic')
                if (node.isClass) {
                    stat.innerHTML = '<p>Intra-Constraints: '
                        + node.statistics.attributes
                        + '</p><p>Inter-Constraints: '
                        + node.statistics.constraints
                        + '</p><p>Constraints targeting this shape: '
                        + node.statistics.partOff
                        + '</p><p>Target: '
                        + node.targetDef + '</p>';
                } else {
                    let range = "<p>"
                    if (node.min != "-1") {
                        if (node.min === node.max)
                            range += "equal: " + node.min
                        else {
                            range += "min: " + node.min
                            if (node.max != "-1") {
                                range += "</p><p>max: " + node.max
                            }
                        }
                    } else if (node.max != "-1") {
                        range += "max: " + node.max
                    }
                    stat.innerHTML = range + '</p>';
                }


                // fill constraints
                document.getElementById('infoTree').innerHTML = "";

                // show info menu and hide node check list
                {#document.getElementById('infoMenu').classList.remove('disable')#}
                {#document.getElementById('nodeChecklist').classList.add('disable')#}

                let tree = new BootstrapTreeView(document.getElementById('infoTree'), {
                    provider: {
                        async getChildren(id) {
                            console.log('Info navigation| id: ' + id)
                            if (!id) { {# a node on the graph is clicked #}
                                selectedNode = node;
                                return [
                                    {
                                        id: node.id,
                                        label: node.text,
                                        icon: {classes: ['fa', 'fa-project-diagram']},
                                        state: 'expanded'
                                    }
                                ];
                            } else {
                                {#if the clicked element is a node#}
                                const res = [];
                                const resSelf = [];
                                const n = nodesById[id];
                                if (n) {
                                    if (n.isHidden) {
                                        n.isHidden = false;
                                        updateHiddenLinks();
                                        updateClassState(n);
                                    } else if (n != selectedNode && !n.expanded) { {# expand the node in graph #}
                                        n.expanded = true;
                                        updateClassState(n);
                                    }

                                    {# fill info menu with node connections #}
                                    if (n.isClass) {
                                        n.childLinks.forEach(link => {
                                            if (!link.isClass2Class) { {# if the link goes to a constraint #}
                                                if (link.isAttribute) { {# if the link goes to self constaint #}
                                                    resSelf.push({
                                                        id: link.id,
                                                        label: link.text,
                                                        icon: {classes: ['bi', 'bi-align-middle']},
                                                        state: 'collapsed'
                                                    })
                                                } else { {# the link goes to another class #}
                                                    res.push({
                                                        id: link.id,
                                                        label: link.text,
                                                        icon: {classes: ['bi', 'bi-arrow-left-right']},
                                                        state: 'collapsed'
                                                    });
                                                }
                                            }
                                        })
                                        resSelf.push(...res)
                                        return resSelf;
                                    } else { {# the node is a constraint => show attributes #}
                                        id = n.parentLinks[0].id
                                    }
                                }

                                {#if the clicked element is a link#}
                                const l = linksById[id];
                                if (l) {
                                    console.log('if the clicked element is a link| ' + l)
                                    let return_list = []

                                    let range = ""
                                    if (l.min != "-1") {
                                        if (l.min === l.max)
                                            range += "equal: " + l.min
                                        else {
                                            range += "min: " + l.min
                                            if (l.max != "-1") {
                                                range += ", max: " + l.max
                                            }
                                        }
                                    } else if (l.max != "-1") {
                                        range += "max: " + l.max
                                    }

                                    if (range != "") {
                                        return_list.push({
                                            id: l.id + ",range",
                                            label: range,
                                            icon: {classes: ['fa', 'fa-drafting-compass']}
                                        })
                                    }

                                    if (l.finalTarget) { {# if the link goes to constraint #}
                                        const ft = nodesById[l.finalTarget];
                                        {# to-do check ft undefinde when clicking on constraint: id: ft.id, #}
                                        return_list.push({
                                            id: ft.id,
                                            label: ft.text,
                                            icon: {classes: ['fa', 'fa-project-diagram']},
                                            state: 'collapsed'
                                        })
                                    } else if (isShowingDataGraph) {
                                        if (l.linkType == 1)
                                            return_list.push({
                                                id: l.id + ",text",
                                                label: getNodeFromLink(l.target).text,
                                                icon: {classes: ['fa-regular', 'fa-file-lines']}
                                            })
                                    }


                                    return return_list;
                                }

                                {#if not found#}
                                return [];

                            }


                        }
                    }
                });
            }

            // shape check list
            const shapeCheckList = {};
            resetShapeCheckList();

            function resetShapeCheckList() {
                const checklist = document.getElementById('nodeChecklist').getElementsByTagName('ul');

                checklist[0].innerHTML = "";

                // show node check list and hide info menu
                {#document.getElementById('nodeChecklist').classList.remove('disable')#}
                {#document.getElementById('infoMenu').classList.add('disable')#}


                // Add a "checked" symbol on click
                checklist[0].addEventListener('click', function (ev) {
                    if (ev.target.tagName === 'LI') {
                        ev.target.classList.toggle('checked');

                        if (ev.target.classList.contains('checked')) {
                            let node = nodesById[ev.target.getAttribute('nodeId')]

                            node.isHidden = false;
                            {#updateClassState(node)#}
                        } else {
                            let node = nodesById[ev.target.getAttribute('nodeId')]

                            node.isHidden = true;
                            node.childLinks.forEach(link => {
                                link.isHidden = true;
                                switch (link.linkType) {
                                    case 0:
                                        break;
                                    case 1:
                                        getNodeFromLink(link.target).isHidden = true;
                                        break;
                                    case 3:
                                        let constraint = getNodeFromLink(link.target);
                                        constraint.isHidden = true;
                                        constraint.childLinks[0].isHidden = true;
                                        break;
                                }
                            })
                            {#updateGraph();#}
                        }
                        updateHiddenLinks();
                        updateGraph();
                    }
                }, false);

                nodes.forEach(node => {
                    if (node.isClass) {
                        const li = document.createElement("li");
                        li.setAttribute('nodeId', node.id);
                        li.appendChild(document.createTextNode(node.text));
                        checklist[0].appendChild(li);

                        if (!node.isHidden) {
                            li.classList.add('checked')
                        }

                        shapeCheckList[node.id] = li;
                    }
                });

                {#console.log(shapeCheckList);#}
            }

            function updateHiddenLinks() {
                links.forEach(link => {
                    // update links if the nodes are hidden or not
                    switch (link.linkType) {
                        case 3:
                            let source = getNodeFromLink(link.source)
                            let constraint = getNodeFromLink(link.target)
                            let finalTarget = getNodeFromLink(link.finalTarget)
                            if (source.isHidden || finalTarget.isHidden) {
                                {#source.isHidden = true;#}
                                constraint.isHidden = true;
                                {#finalTarget.isHidden = true;#}
                                constraint.parentLinks.forEach(l => l.isHidden = true)
                                constraint.childLinks.forEach(l => l.isHidden = true)
                            } else {
                                constraint.isHidden = false;
                                constraint.parentLinks.forEach(l => l.isHidden = false)
                                constraint.childLinks.forEach(l => l.isHidden = false)
                            }
                            break;
                        case 1: {# do nothing to attributes #}
                        {#if (!hideAttributes) {
                            link.isHidden = false;
                            getNodeFromLink(link.target).isHidden = false;
                        } else {
                            link.isHidden = true;
                            getNodeFromLink(link.target).isHidden = true;
                        }#}
                            if (getNodeFromLink(link.source).isHidden) {
                                link.isHidden = true;
                                getNodeFromLink(link.target).isHidden = true;
                            } else {
                                link.isHidden = false;
                                getNodeFromLink(link.target).isHidden = false;
                            }
                            break;
                        default:
                            if (getNodeFromLink(link.source).isHidden || getNodeFromLink(link.target).isHidden) {
                                link.isHidden = true;
                            } else {
                                link.isHidden = false
                            }
                            break;
                    }

                });
            }

            {# validation #}

            function requestValidationData(node) {
                console.log("requestValidationData")

                //get endpoint
                let endpoint = endpointInputBox.value
                if (endpoint === "") {
                    $('#flash').append(flashMessage("Select the validation endpoint", 'warning'));
                    openAccordion(document.querySelector('#ValidationEndpointAccordion'))
                    endpointInputBox.focus();
                    return false;
                }

                let dir = "{{ request.args.get("path") }}";
                let config = {
                    external_endpoint: endpoint,
                    outputDirectory: "./output/",
                    query: "PREFIX ub:<http://swat.cse.lehigh.edu/onto/univ-bench.owl#> PREFIX :<http://example.com/>" + node.query,
                    schemaDir: "./main/shacljson/example" + dir,
                    targetShape: node.id,
                    backend: "travshacl",
                    output_format: "test"
                }

                console.log("query:" + config.query)
                console.log("node.query:" + node.query)
                console.log("targetShape:" + config.targetShape)

                {#
                    JSON structure:
                    {shape1:
                        {valid: #valid instances,
                        invalid: #invalid instances,
                        columns: [column name 1, column name 2, ...],
                        results: [[instance 1 data 1,instance 1 data 2, ...], [instance 2 data 1,instance 2 data 2, ...], ...]
                        }
                    shape2: {...}
                    ...
                    }
                #}
                let request_validation = $.ajax({
                    url: "/validation",
                    type: "POST",
                    data: config,
                    success: function (data, textStatus, jqXHR) {
                        console.log("validation request success")
                        console.log(data)
                        console.log(textStatus)
                        console.log(jqXHR)

                        //save endpoint to cache
                        saveToCache(endpointInputBox.id, endpoint)

                        {# get current shape node #}
                        let currentNode;
                        if (selectedNode.isClass)
                            currentNode = selectedNode;
                        else
                            currentNode = selectedNode.parentLinks[0];

                        Object.keys(data).forEach(shapeId => {
                            let shape = nodesById[shapeId]
                            {# fill valid/invalid count #}
                            shape.valid = data[shapeId].valid
                            shape.invalid = data[shapeId].invalid
                            {# cacluate validation percent #}
                            if (shape.valid === 0 && shape.invalid === 0)
                                shape.validPercent = 100
                            else
                                shape.validPercent = Math.floor(10000 * shape.valid / (shape.valid + shape.invalid)) / 100;
                            {# fill data #}
                            shape.columns = data[shapeId].columns
                            shape.data = data[shapeId].results

                            validationData.add(shape)

                            {# request returned so remove it from request map #}
                            delete requestMap[shapeId];

                            {# update validation tab #}
                            if (shapeId === currentNode.id) {
                                fillValidationData()
                                requestBtnClicked(false)
                            } else
                                {# only update total validation data in the validation tab #}
                                updateTotalValidation()
                        })

                    },
                    error: function (jqXHR, exception) {
                        console.log("validation request error:")
                        console.log(jqXHR.status)
                        console.log(exception)
                        let msg = '';
                        if (jqXHR.status === 0) {
                            msg = ': Cannot connect to ShaclAPI';
                        } else if (jqXHR.status === 404) {
                            msg = ': Requested page not found. [404]';
                        } else if (jqXHR.status === 500) {
                            msg = ': Internal Server Error [500].';
                        } else if (exception === 'parsererror') {
                            msg = ': Requested JSON parse failed.';
                        } else if (exception === 'timeout') {
                            msg = ': Time out error.';
                        } else if (exception === 'abort') {
                            msg = ': Ajax request aborted.';
                        } else {
                            msg = ': Uncaught Error.\n' + jqXHR.responseText;
                        }
                        $('#flash').append(flashMessage(node.id + msg, 'warning'));

                        {# request returned so remove it from request map #}
                        delete requestMap[node.id];

                        let currentNode;
                        if (selectedNode.isClass)
                            currentNode = selectedNode;
                        else
                            currentNode = selectedNode.parentLinks[0];

                        if (node.id === currentNode.id) {
                            requestBtnClicked(false)
                        }
                    }
                });

                requestMap[node.id] = request_validation
                node.colorRange = 5

                let request_node_list = $.ajax({
                    url: "/reduce",
                    type: "POST",
                    data: config,
                    success: function (data, textStatus, jqXHR) {
                        console.log("reduce result success")
                        console.log(data)
                        console.log(textStatus)
                        console.log(jqXHR)

                        data['shapes'].forEach(shapeId => {
                            let shape = nodesById[shapeId]
                            if (shape.valid === -1 || shape.invalid === -1) {
                                requestMap[shapeId] = request_validation
                                shape.colorRange = 5
                            }
                        })
                        updateNode3d();
                    },
                    error: function (jqXHR, exception) {
                        console.log("reduce result error:")
                        console.log(jqXHR.status)
                        console.log(exception)
                        let msg = '';
                        if (jqXHR.status === 0) {
                            msg = ': Cannot connect to ShaclAPI';
                        } else if (jqXHR.status === 404) {
                            msg = ': Requested page not found. [404]';
                        } else if (jqXHR.status === 500) {
                            msg = ': Internal Server Error [500].';
                        } else if (exception === 'parsererror') {
                            msg = ': Requested JSON parse failed.';
                        } else if (exception === 'timeout') {
                            msg = ': Time out error.';
                        } else if (exception === 'abort') {
                            msg = ': Ajax request aborted.';
                        } else {
                            msg = ': Uncaught Error.\n' + jqXHR.responseText;
                        }
                        $('#flash').append(flashMessage(node.id + msg, 'warning'));

                        {# request returned so remove it from request map #}
                        delete requestMap[node.id];

                        let currentNode;
                        if (selectedNode.isClass)
                            currentNode = selectedNode;
                        else
                            currentNode = selectedNode.parentLinks[0];

                        if (node.id === currentNode.id) {
                            requestBtnClicked(false)
                        }
                    }
                });

                return true;
            }

            let validationData = {

                settings: {
                    highValidPercent: 10,
                    lowValidPercent: 40
                },
                validatedNodes: [],
                totalShapes: {{ graph|length }},
                totalValid: 0,
                totalInvalid: 0,
                low: 0,
                med: 0,
                high: 0,
                allValid: 0,
                add: function (node) { {# colorRange[ 0:unvalidated, 1:allValid, 2:low, 3:medium, 4:high ] #}
                    if (!this.validatedNodes.includes(node)) {
                        switch (true) {
                            case (node.validPercent < this.settings.highValidPercent):
                                this.high++;
                                node.colorRange = 4;
                                break;
                            case (node.validPercent < this.settings.lowValidPercent):
                                this.med++;
                                node.colorRange = 3;
                                break;
                            case (node.validPercent < 100):
                                this.low++;
                                node.colorRange = 2;
                                break;
                            case (node.validPercent === 100):
                                this.allValid++;
                                node.colorRange = 1;
                                break;
                        }
                        updateNode3d();
                        this.totalValid += node.valid
                        this.totalInvalid += node.invalid
                        this.validatedNodes.push(node)
                    }
                },
                updateRange: function () {
                    {# recalculate low/med/high #}
                    this.low = this.med = this.high = this.allValid = this.totalValid = this.totalInvalid = 0
                    this.validatedNodes.forEach(node => {
                        switch (true) {
                            case (node.validPercent < this.settings.highValidPercent):
                                this.high++;
                                node.colorRange = 4;
                                break;
                            case (node.validPercent < this.settings.lowValidPercent):
                                this.med++;
                                node.colorRange = 3;
                                break;
                            case (node.validPercent < 100):
                                this.low++;
                                node.colorRange = 2;
                                break;
                            case (node.validPercent === 100):
                                this.allValid++;
                                node.colorRange = 1;
                                break;
                        }
                        if (requestMap[node.id]) // node is validating
                            node.colorRange = 5

                        this.totalValid += node.valid
                        this.totalInvalid += node.invalid
                    })
                }
            }

            let requestMap = {}

            function fillValidationData() {
                console.log("fillValidationData")

                {# fill total validation #}
                updateTotalValidation()

                {# fill selected validation #}

                let shapeNode;
                if (selectedNode.isClass)
                    shapeNode = selectedNode;
                else
                    shapeNode = getNodeFromLink(selectedNode.parentLinks[0].source);


                console.log("selectedNode: " + selectedNode.text)
                console.log("selectedNode.isClass: " + selectedNode.isClass)
                console.log("shapeNode: " + shapeNode.text)

                let statNode = document.getElementById('selectedValidationData')
                if (shapeNode.valid < 0) {
                    {# show request button #}
                    document.getElementById('requestValidationBtn').style.display = "block"
                    document.getElementById('ViewDataBtn').style.display = "none"

                    {# check if already requested or not #}
                    if (requestMap[shapeNode.id]) {
                        requestBtnClicked(true)
                    } else {
                        requestBtnClicked(false)
                    }
                    {# clear validation data #}
                    statNode.innerHTML = ''
                } else {
                    {# hide request button #}
                    document.getElementById('requestValidationBtn').style.display = "none"
                    document.getElementById('ViewDataBtn').style.display = "block"

                    {# fill validation data #}
                    statNode.innerHTML =
                        '<p>Valid Percentage:</p>'
                        + "<p style=\'background: linear-gradient(90deg, rgb(0 90 255) 0%, rgb(0 90 255) " + shapeNode.validPercent + "%, rgb(192 0 0) " + shapeNode.validPercent + "%, rgb(192 0 0) 100%);\'"
                        + " class=\'powerbar\'>"
                        + shapeNode.validPercent + "%</p>"
                        + "<table><tr><td>Valid: " + shapeNode.valid + "</td><td>"
                        + "Invalid: " + shapeNode.invalid + "</td></tr></table>";
                }
            }

            function updateTotalValidation() {
                {# fill total validation #}
                let statTotal = document.getElementById('totalValidationData')

                {# calculate low,med,high percent #}
                let total = validationData.allValid + validationData.low + validationData.med + validationData.high
                let allValidP = 100 * validationData.allValid / total;
                let lowP = 100 * (validationData.allValid + validationData.low) / total;
                let medP = 100 * (validationData.allValid + validationData.low + validationData.med) / total;

                let validDataPercent = Math.floor(10000 * validationData.totalValid / (validationData.totalValid + validationData.totalInvalid)) / 100
                if (validationData.totalValid === 0 && validationData.totalInvalid === 0)
                    validDataPercent = 100;

                statTotal.innerHTML =
                    '<p>Shapes processed: ' + validationData.validatedNodes.length + '/' + validationData.totalShapes +
                    '</p>'
                    + "<p style=\'background: linear-gradient(90deg, rgb(0 192 0) 0%, rgb(0 192 0) " + allValidP
                    + "%, rgb(255 255 0) " + allValidP
                    + "%, rgb(255 255 0) " + lowP
                    + "%, rgb(255 128 0) " + lowP
                    + "%, rgb(255 128 0) " + medP
                    + "%, rgb(192 0 0) " + medP
                    + "%, rgb(192 0 0) 100%);\'"
                    + " class=\'powerbar\'>"
                    + "</p>"
                    + "<table><tr><td>Low: " + validationData.low + "</td><td>"
                    + "Medium: " + validationData.med + "</td><td>"
                    + "High: " + validationData.high + "</td></tr></table>"
                    + '<p>Validation Data:</p>'
                    + "<p style=\'background: linear-gradient(90deg, rgb(13 110 253) 0%, rgb(13 110 253) " + validDataPercent
                    + "%, rgb(192 0 0) " + validDataPercent
                    + "%, rgb(192 0 0) 100%);\'"
                    + " class=\'powerbar\'>"
                    + validDataPercent + "%</p>"
                    + "<table><tr><td>Valid: " + validationData.totalValid + "</td><td>"
                    + "Invalid: " + validationData.totalInvalid + "</td></tr></table>";
            }

            function requestBtnClicked(clicked) {
                let btn = document.getElementById('requestValidationBtn');
                if (clicked) {
                    btn.classList.add("sending", "btn-secondary")
                    btn.classList.remove("btn-primary")
                    btn.textContent = "Validating, click to cancel"
                    btn.blur()
                } else {
                    btn.classList.remove("sending", "btn-secondary")
                    btn.classList.add("btn-primary")
                    btn.textContent = "Request Validation"
                    btn.blur()
                }
            }


            // HTML calls
            document.querySelector("#collapseAll").onclick = () => {
                nodes.forEach(node => node.isClass ? node.expanded = false : node.expanded = true);
                links.forEach(link => link.isClass2Class ? link.collapsed = false : link.collapsed = true);
                updateGraph();
            }

            document.querySelector("#expandAll").onclick = () => {
                nodes.forEach(node => node.isClass ? node.expanded = true : node.expanded = false);
                {#nodes.forEach(node => node.expanded = true);#}
                links.forEach(link => link.isClass2Class ? link.collapsed = true : link.collapsed = false);
                updateGraph();
            }

            document.querySelector("#centerGraph").onclick = () => {
                Graph.zoomToFit(400);
            }

            document.querySelector("#focusNode").onclick = () => {
                {# check selected node #}
                if (null == selectedNode) {
                    $('#flash').append(flashMessage(`Select a Shape first`, 'warning'));
                } else {
                    focusNode(selectedNode);
                }

            }

            let hideUnrelatedClasses = false;
            document.querySelector('#hideUnrelatedClasses').onclick = () => {

                const checkbox = $("#hideUnrelatedClasses").find('input:checkbox:first');
                console.log('hideUnrelatedClasses| checkbox.prop(\'checked\')| ' + checkbox.prop('checked'));

                {# check selected node #}
                if (null == selectedNode) {
                    $('#flash').append(flashMessage(`Select a Shape first`, 'warning'));
                    return;
                }

                if (hideUnrelatedClasses) {
                    checkbox.prop('checked', false);
                    hideUnrelatedClasses = false;

                    nodes.forEach(node => node.isHidden = false)
                    links.forEach(link => link.isHidden = false)

                    {#updateClassState(selectedNode)#}
                    updateGraph();
                } else {
                    checkbox.prop('checked', true);
                    hideUnrelatedClasses = true;

                    hideAllButSelectedNode();
                }

                // open node checklist and fill it
                openRightNav('shape');

                // center graph without changing the zoom
                {#setTimeout(() => Graph.zoomToFit(400),500)#}

            }

            function hideAllButSelectedNode() {
                {# hide all nodes and links #}
                nodes.forEach(node => node.isHidden = true)
                {#links.forEach(link => link.isHidden = true)#}{# debricated #}

                selectedNode.isHidden = false;
                {# get class to class links and show classes #}
                {# debricated #}
                {#selectedNode.childLinks.forEach(link => {

                    if (link.isClass2Class) { #}{# show all links not class to class #}{#
                        #}{#console.log("selectedNode| id: " + selectedNode.id + " .expanded: " + selectedNode.expanded)#}{#

                        #}{#if (!selectedNode.expanded) #}{# alwasy show, .expanded will take care of it#}{#
                        link.isHidden = false;

                    } else { #}{# show constraints classes #}{#
                        link.isHidden = false;

                        let constraintNode = getNodeFromLink(link.target);
                        constraintNode.isHidden = false;
                        if (!constraintNode.isClass)#}{# meaning the selected node is not a constraint #}{#
                            constraintNode.childLinks.forEach(l => {
                                l.isHidden = false
                            });

                        if (link.finalTarget) {
                            getNodeFromLink(link.finalTarget).isHidden = false;
                        }
                    }
                });#}
                selectedNode.childLinks.forEach(link => {
                    if (link.isClass2Class) {
                        getNodeFromLink(link.target).isHidden = false;
                    }
                });
                updateHiddenLinks();

                updateGraph();
            }

            let highlightSelectedNode = true;
            document.querySelector('#highlightSelectedNode').onclick = () => {

                const checkbox = $("#highlightSelectedNode").find('input:checkbox:first');
                console.log('highlightSelectedNode| checkbox.prop(\'checked\')| ' + checkbox.prop('checked'));

                if (highlightSelectedNode) {
                    checkbox.prop('checked', false);
                    highlightSelectedNode = false;

                    nodes.forEach(node => node.highlighted = false)
                    links.forEach(link => link.highlighted = false)
                    updateNode3d();
                } else {
                    checkbox.prop('checked', true);
                    highlightSelectedNode = true;

                    highlightNode(selectedNode)
                }

            }

            {#Search box#}
            let suggestions = [];
            nodes.forEach(node => node.isClass ? suggestions.push(node.text) : null);
            {#console.log(suggestions)#}

            // getting all required elements
            const searchWrapper = document.querySelector("#search-wrapper");
            const inputBox = searchWrapper.querySelector("#search-input");
            const suggBox = searchWrapper.querySelector("#search-sugg");
            const icon = searchWrapper.querySelector("#search-icon");
            let linkTag = searchWrapper.querySelector("#search-linkTag");

            // if user press any key and release
            inputBox.onkeyup = (e) => {
                suggest(e);
            }
            inputBox.onfocus = (e) => {
                inputBox.value = '';
                suggest(e);
            }

            function suggest(e) {
                let userData = e.target.value; //user entered data
                let emptyArray = [];
                {#if (userData) {#}
                icon.onclick = () => {

                }
                emptyArray = suggestions.filter((data) => {
                    {#console.log("inputBox.onkeyup.userData = " + userData)#}
                    if (userData)
                        //filtering array value and user characters to lowercase and return only those words which are start with user entered chars
                        return data.toLocaleLowerCase().startsWith(userData.toLocaleLowerCase());
                    else
                        return data;
                });
                emptyArray = emptyArray.map((data) => {
                    // passing return data inside li tag
                    return data = `<li>${data}</li>`;
                });
                searchWrapper.classList.add("active"); //show autocomplete box
                showSuggestions(emptyArray.sort());
                let allList = suggBox.querySelectorAll("li");
                let clicked = false;
                {# fix on mouse out will hide the highlight after clicking #}
                for (let i = 0; i < allList.length; i++) {
                    //adding onclick attribute in all li tag
                    allList[i].onclick = () => {
                        clicked = true;
                        select(allList[i])
                        viewNodeInfo(nodesById[allList[i].textContent])
                        {# viewNodeInfo will set selectedNode #}
                        if (nodesById[allList[i].textContent].isHidden) {
                            if (hideUnrelatedClasses)
                                hideAllButSelectedNode();
                            else {
                                nodesById[allList[i].textContent].isHidden = false;
                                updateHiddenLinks()
                                updateGraph();
                            }
                        } else {
                            updateClassState(nodesById[allList[i].textContent])
                        }
                    };
                    allList[i].onmouseover = () => {
                        highlightSelectedNode ? highlightNode(nodesById[allList[i].textContent]) : null
                    }
                }
                suggBox.onmouseout = () => {
                    if (highlightSelectedNode) {
                        if (clicked) { {# when an item is clicked and searchWrapper disappear dont remove highlight #}
                            clicked = false;
                            return;
                        }

                        nodes.forEach(node => node.highlighted = false)
                        links.forEach(link => link.highlighted = false)
                        updateNode3d();
                    }
                }
                {# } else {
                     searchWrapper.classList.remove("active"); //hide autocomplete box
                 }#}
            }

            var mouse_is_inside = false;
            searchWrapper.onmouseover = () => {
                mouse_is_inside = true;
            }
            searchWrapper.onmouseout = () => {
                mouse_is_inside = false;
            }

            document.querySelector("body").onmouseup = () => {
                {#console.log("body.onmouseup.mouse_is_inside = " + mouse_is_inside)#}
                if (!mouse_is_inside) searchWrapper.classList.remove("active"); //hide autocomplete box
            }

            function select(element) {
                let selectData = element.textContent;
                inputBox.value = selectData;
                icon.onclick = () => {
                    {#highlightNode(nodesById[selectData])#}
                    updateClassState(nodesById[selectData])
                    viewNodeInfo(nodesById[selectData])
                }
                searchWrapper.classList.remove("active");
            }

            function showSuggestions(list) {
                let listData;
                if (!list.length) {
                    let userValue = inputBox.value;
                    listData = `<li>${userValue}</li>`;
                } else {
                    listData = list.join('');

                    {#listData = `<li>${suggestions}</li>`;#}
                }
                suggBox.innerHTML = listData;
            }

            document.querySelector('#hideAttributes').onclick = () => {

                const checkbox = $("#hideAttributes").find('input:checkbox:first');
                console.log('hideAttributes| checkbox.prop(\'checked\')| ' + checkbox.prop('checked'));

                if (hideAttributes) {
                    checkbox.prop('checked', false);
                    hideAttributes = false;

                    {#nodes.forEach(node => node.isAttribute ? node.isHidden = false : null)#}
                    {#links.forEach(link => link.isAttribute ? link.isHidden = false : null)#}

                    updateGraph();
                } else {
                    checkbox.prop('checked', true);
                    hideAttributes = true;

                    {#nodes.forEach(node => node.isAttribute ? node.isHidden = true : null)#}
                    {#links.forEach(link => link.isAttribute ? link.isHidden = true : null)#}

                    updateGraph();
                }
            }

            // link length slider update value from default settings
            document.querySelector('#class2classLinkSlider').value = settings.linkLengthClass2Class
            document.querySelector('#attributeLinkSlider').value = settings.linkLengthAttribute
            document.querySelector('#toConstraintLinkSlider').value = settings.linkLengthToConstraint
            document.querySelector('#fromConstraintLinkSlider').value = settings.linkLengthFromConstraint
            document.querySelector('#class2classLinkSlider').nextElementSibling.value = settings.linkLengthClass2Class
            document.querySelector('#attributeLinkSlider').nextElementSibling.value = settings.linkLengthAttribute
            document.querySelector('#toConstraintLinkSlider').nextElementSibling.value = settings.linkLengthToConstraint
            document.querySelector('#fromConstraintLinkSlider').nextElementSibling.value = settings.linkLengthFromConstraint
            // link length slider listeners
            document.querySelector('#class2classLinkSlider').oninput = function () {
                this.nextElementSibling.value = this.value
                settings.linkLengthClass2Class = this.value
                updateLinkDistance();
            }
            document.querySelector('#attributeLinkSlider').oninput = function () {
                this.nextElementSibling.value = this.value
                settings.linkLengthAttribute = this.value
                updateLinkDistance();
            }
            document.querySelector('#toConstraintLinkSlider').oninput = function () {
                this.nextElementSibling.value = this.value
                settings.linkLengthToConstraint = this.value
                updateLinkDistance();
            }
            document.querySelector('#fromConstraintLinkSlider').oninput = function () {
                this.nextElementSibling.value = this.value
                settings.linkLengthFromConstraint = this.value
                updateLinkDistance();
            }

            // Validation percentage slider update value from default settings
            document.querySelector('#lowValidationPercentage').value = 100 - validationData.settings.lowValidPercent
            document.querySelector('#HighValidationPercentage').value = 100 - validationData.settings.highValidPercent
            document.querySelector('#lowValidationPercentage').nextElementSibling.value = 100 - validationData.settings.lowValidPercent
            document.querySelector('#HighValidationPercentage').nextElementSibling.value = 100 - validationData.settings.highValidPercent
            // Validation percentage slider listeners
            document.querySelector('#lowValidationPercentage').oninput = function () {
                this.nextElementSibling.value = this.value
                validationData.settings.lowValidPercent = 100 - this.value
                validationData.updateRange()
                updateNode3d();
                updateTotalValidation()
            }
            document.querySelector('#HighValidationPercentage').oninput = function () {
                this.nextElementSibling.value = this.value
                validationData.settings.highValidPercent = 100 - this.value
                validationData.updateRange()
                updateNode3d();
                updateTotalValidation()
            }

            {# add accordion button listeners #}
            let acc = document.querySelectorAll(".accordion");
            for (let i = 0; i < acc.length; i++) {
                toggleAccordion(acc[i])
                acc[i].addEventListener("click", function () {
                    this.classList.toggle("active");
                    toggleAccordion(this);
                    {#let panel = this.nextElementSibling;
                    if (panel.style.maxHeight) {
                        panel.style.maxHeight = null;
                    } else {
                        panel.style.maxHeight = panel.scrollHeight + "px";
                    }#}
                });
            }

            function toggleAccordion(accordionBtn) {
                let panel = accordionBtn.nextElementSibling;
                if (accordionBtn.classList.contains("active")) {
                    {#panel.style.maxHeight = panel.scrollHeight + "px";#}
                    panel.style.maxHeight = "fit-content";
                    if (panel.style.overflow)
                        panel.style.overflow = "visible";
                } else {
                    panel.style.maxHeight = null;
                    if (panel.style.overflow)
                        panel.style.overflow = 'hidden';
                }
            }

            function openAccordion(accordionBtn) {
                let panel = accordionBtn.nextElementSibling;
                panel.style.maxHeight = "fit-content";
                if (panel.style.overflow)
                    panel.style.overflow = "visible";
            }

            {# navigation panels #}
            // Sidenav Push Content
            let isNavOpen = false;

            /* Set the width of the side navigation to 250px and the left margin of the page content to 250px */
            function openNav() {
                isNavOpen = true;
                document.getElementById("mySidenav").classList.remove("closeLeftNav");
                document.getElementById("data-table-container").style.marginLeft = "285px";
            }

            /* Set the width of the side navigation to 0 and the left margin of the page content to 0 */
            function closeNav() {
                isNavOpen = false;
                document.getElementById("mySidenav").classList.add("closeLeftNav");
                document.getElementById("data-table-container").style.marginLeft = "0";
            }

            document.querySelector('#optionBtn').onclick = () => {
                if (isNavOpen) {
                    closeNav()
                } else {
                    openNav()
                }
            }

            let isRightNavOpen = false;

            function openRightNav(selectedTab) {
                {# the user know about the panel so no need to open it on 'info' tab for the first time click #}
                isRightNavOpenedBefore = true;

                isRightNavOpen = true;
                document.getElementById("myRightSidenav").classList.remove("closeRightNav");
                document.getElementById("rightTabs").classList.add("tabs-openRightNav");
                document.getElementById("rightButtons").classList.add("tabs-openRightNav");
                document.getElementById("data-table-container").style.marginRight = "400px";
                switch (selectedTab) {
                    case 'info':
                        document.getElementById('infoBtn').classList.add('selected')
                        document.getElementById('shapeBtn').classList.remove('selected')
                        document.getElementById('validationBtn').classList.remove('selected')

                        // show info menu and hide node check list
                        document.getElementById('infoMenu').classList.remove('disable')
                        document.getElementById('nodeChecklist').classList.add('disable')
                        document.getElementById('validationMenu').classList.add('disable')

                    {#if (node) viewNodeInfo(node)#}
                        break;

                    case 'shape':
                        document.getElementById('infoBtn').classList.remove('selected')
                        document.getElementById('shapeBtn').classList.add('selected')
                        document.getElementById('validationBtn').classList.remove('selected')

                        // show node check list and hide info menu
                        document.getElementById('infoMenu').classList.add('disable')
                        document.getElementById('nodeChecklist').classList.remove('disable')
                        document.getElementById('validationMenu').classList.add('disable')

                        break;

                    case 'validation':
                        document.getElementById('infoBtn').classList.remove('selected')
                        document.getElementById('shapeBtn').classList.remove('selected')
                        document.getElementById('validationBtn').classList.add('selected')

                        // show node check list and hide info menu
                        document.getElementById('infoMenu').classList.add('disable')
                        document.getElementById('nodeChecklist').classList.add('disable')
                        document.getElementById('validationMenu').classList.remove('disable')

                        break;
                }
            }

            function closeRightNav() {
                isRightNavOpen = false;
                document.getElementById("myRightSidenav").classList.add("closeRightNav");
                document.getElementById("rightTabs").classList.remove("tabs-openRightNav");
                document.getElementById("rightButtons").classList.remove("tabs-openRightNav");
                document.getElementById("data-table-container").style.marginRight = "0px";

                document.getElementById('infoBtn').classList.remove('selected')
                document.getElementById('shapeBtn').classList.remove('selected')
                document.getElementById('validationBtn').classList.remove('selected')
            }

            document.querySelector('#infoBtn').onclick = () => {
                if (isRightNavOpen && !document.getElementById("infoBtn").classList.contains("selected")) {
                    openRightNav('info')
                } else if (isRightNavOpen && document.getElementById("infoBtn").classList.contains("selected")) {
                    closeRightNav()
                } else { //it is closed
                    openRightNav('info')
                }
            }
            document.querySelector('#shapeBtn').onclick = () => {
                if (isRightNavOpen && !document.getElementById("shapeBtn").classList.contains("selected")) {
                    openRightNav('shape')
                } else if (isRightNavOpen && document.getElementById("shapeBtn").classList.contains("selected")) {
                    closeRightNav()
                } else { //it is closed
                    openRightNav('shape')
                }
            }
            document.querySelector('#validationBtn').onclick = () => {
                if (isRightNavOpen && !document.getElementById("validationBtn").classList.contains("selected")) {
                    openRightNav('validation')
                } else if (isRightNavOpen && document.getElementById("validationBtn").classList.contains("selected")) {
                    closeRightNav()
                } else { //it is closed
                    openRightNav('validation')
                }
            }

            let darkMode = true;
            document.querySelector('#darkMode').onclick = () => {

                const checkbox = $("#darkMode").find('input:checkbox:first');
                console.log('darkMode| checkbox.prop(\'checked\')| ' + checkbox.prop('checked'));

                if (darkMode) {
                    checkbox.prop('checked', false);
                    darkMode = false;

                    document.documentElement.setAttribute('data-theme', 'light');

                } else {
                    checkbox.prop('checked', true);
                    darkMode = true;

                    document.documentElement.setAttribute('data-theme', 'dark');
                }

                // update graph
                Graph.backgroundColor(getComputedStyle(document.documentElement).getPropertyValue('--main-background').trim());
                updateNode3d();
            }

            document.querySelector('#requestValidationBtn').onclick = (e) => {
                let shapeNode;
                if (selectedNode.isClass)
                    shapeNode = selectedNode;
                else
                    shapeNode = getNodeFromLink(selectedNode.parentLinks[0].source);

                {# check if the request is sent and abort it#}
                if (requestMap[shapeNode.id]) {
                    {#requestMap[shapeNode.id].abort();#}
                    delete requestMap[shapeNode.id];
                    {# change style #}
                    requestBtnClicked(false)
                } else {
                    if (requestValidationData(shapeNode))
                        {# change style #}
                        requestBtnClicked(true)
                }
            }

            document.querySelector('#ViewDataBtn').onclick = (e) => {
                {# view selected node data#}
                let html = '<table id="myTable" class="display"><thead><tr>'
                let dataIndex = selectedNode.columns.indexOf('Data')

                selectedNode.columns.forEach(col => {
                    html += '<th>' + col + '</th>'
                })

                html += '<th>View Data</th></tr></thead><tbody>'

                selectedNode.data.forEach(row => {
                    html += '<tr>'

                    row.forEach(cell => {
                        html += '<td>' + cell + '</td>'
                    })

                    html += '<td><button query-data="' + row[dataIndex] + '" class="btn btn-primary view-data-graph" style="display: block;">View</button></td>'
                    html += '</tr>'
                })

                html += '</tbody></table>'

                document.getElementById('data-table').innerHTML = html
                $('#myTable').DataTable();

                // button click showDataGraph
                $('#myTable').on('click', '.view-data-graph', function () {
                    showDataGraph(selectedNode, $(this).attr("query-data"))
                    closeDataTable()
                });

                {# show table #}
                showDataTable()
            }

            document.querySelector('#close-table-btn').onclick = (e) => {
                closeDataTable()
            }

            function showDataTable() {
                elem.style.display = "none";
                document.getElementById('data-table-container').style.display = "block";
                Graph.pauseAnimation()
            }

            function closeDataTable() {
                elem.style.display = "block";
                document.getElementById('data-table-container').style.display = "none";
                Graph.resumeAnimation()
            }

            {#document.querySelector('#validationEndpointDropdown').onchange = () => {
                let dropdown = $("#validationEndpointDropdown")[0];
                let val = dropdown.options[dropdown.selectedIndex].value;
                $("#validationEndpointTextBox").val(val);
            }#}

            {#validation endpoint box#}

            // getting all required elements
            const endpointWrapper = document.querySelector("#endpointWrapper");
            const endpointInputBox = endpointWrapper.querySelector("#endpointInputBox");
            const endpointSuggBox = endpointWrapper.querySelector("#endpointSuggBox");
            const endpointIcon = endpointWrapper.querySelector("#endpointIcon");
            let endpointLinkTag = endpointWrapper.querySelector("#endpointLinkTag");

            let endpointList = [
                "http://host.docker.internal:9000/sparql",
                "http://127.0.0.1:9000/sparql",
                "http://shacl_api_testdata:8890/sparql",
                "http://192.168.111.1:14000/sparql",
                "https://labs.tib.eu/sdm/clarify-kg-7/sparql"];
            saveToCacheDefaultValues(endpointInputBox.id, endpointList)

            // if user press any key and release
            endpointInputBox.onkeyup = (e) => {
                endpointSuggest(e.target.value);
            }
            endpointInputBox.onfocus = (e) => {
                {#endpointInputBox.value = '';#}
                endpointSuggest(e.target.value);
            }

            endpointIcon.onclick = () => {
                endpointSuggest()
            }

            function endpointSuggest(userData) {
                let emptyArray = [];
                emptyArray = getFromCache(endpointInputBox.id).filter((data) => {
                    {#console.log("inputBox.onkeyup.userData = " + userData)#}
                    if (userData)
                        //filtering array value and user characters to lowercase and return only those words which are start with user entered chars
                        return data.toLocaleLowerCase().startsWith(userData.toLocaleLowerCase());
                    else
                        return data;
                });
                emptyArray = emptyArray.map((data) => {
                    // passing return data inside li tag
                    return data = `<li>${data}</li>`;
                });
                endpointWrapper.classList.add("active"); //show autocomplete box
                showEndpointSuggestions(emptyArray.sort());
                let allList = endpointSuggBox.querySelectorAll("li");
                let clicked = false;
                {# fix on mouse out will hide the highlight after clicking #}
                for (let i = 0; i < allList.length; i++) {
                    //adding onclick attribute in all li tag
                    allList[i].onclick = () => {
                        clicked = true;
                        selectEndpoint(allList[i])
                    };
                }
            }

            var mouse_is_inside_endpoint = false;
            endpointWrapper.onmouseover = () => {
                mouse_is_inside_endpoint = true;
            }
            endpointWrapper.onmouseout = () => {
                mouse_is_inside_endpoint = false;
            }

            document.querySelector("body").onmouseup = () => {
                {#console.log("body.onmouseup.mouse_is_inside = " + mouse_is_inside)#}
                if (!mouse_is_inside_endpoint) endpointWrapper.classList.remove("active"); //hide autocomplete box
            }

            function selectEndpoint(element) {
                let selectData = element.textContent;
                endpointInputBox.value = selectData;
                {#endpointIcon.onclick = () => {
                    #}{#highlightNode(nodesById[selectData])#}{#
                    #}{#updateClassState(nodesById[selectData])
                    viewNodeInfo(nodesById[selectData])#}{#
                }#}
                endpointWrapper.classList.remove("active");
            }

            function showEndpointSuggestions(list) {
                let listData;
                if (!list.length) {
                    let userValue = inputBox.value;
                    listData = `<li>${userValue}</li>`;
                } else {
                    listData = list.join('');

                    {#listData = `<li>${suggestions}</li>`;#}
                }
                endpointSuggBox.innerHTML = listData;
            }

            // save cache list to local storage
            function saveToCache(id, value) {
                let json = localStorage.getItem(id)
                let array
                if (json != null) {
                    array = JSON.parse(json)
                    let set = new Set(array).add(value) //no doubles
                    array = Array.from(set)
                } else {
                    array = [value]
                }
                let json2 = JSON.stringify(array)
                localStorage.setItem(id, json2)
            }

            function saveToCacheDefaultValues(id, array) {
                {#localStorage.removeItem(id)#}

                let json = localStorage.getItem(id)
                if (json == null) {
                    json = JSON.stringify(array)
                    localStorage.setItem(id, json)
                }
            }

            function getFromCache(id) {
                let c = localStorage.getItem(id)
                if (c != null)
                    return Array.from(JSON.parse(c))
                else
                    return []
            }


            {# Data viewer #}

            function showShapeGraph() {
                {# restore #}
                nodes.length = 0
                links.length = 0
                nodes.push(...backupNodes)
                links.push(...backupLinks)
                selectedNode = bachupSelectedNode
                {# empty backup data #}
                backupNodes.length = 0
                backupLinks.length = 0
                bachupSelectedNode = null

                isShowingDataGraph = false
                resetGraphMaps()
                resetShapeCheckList()
                updateGraph()
                viewNodeInfo(selectedNode)
                fillValidationData()
            }

            function showDataGraph(shape, id) {
                loading(true)

                requestDataNode(shape, id, function (json) {

                    // show data graph
                    let graph = creatDataNetwork(shape, id, json)
                    {# backup #}
                    backupNodes.length = 0
                    backupLinks.length = 0
                    backupNodes.push(...nodes)
                    backupLinks.push(...links)
                    bachupSelectedNode = selectedNode
                    {# show #}
                    nodes.length = 0
                    links.length = 0
                    nodes.push(graph.main)
                    nodes.push(...graph.nodes)
                    links.push(...graph.links)
                    selectedNode = graph.main

                    isShowingDataGraph = true
                    resetGraphMaps(true)
                    resetShapeCheckList()
                    updateGraph()

                    openRightNav('info')
                    document.getElementById('validationBtn').style.display = "none"
                    document.getElementById('rightButtons').style.display = "flex"

                    loading(false)
                }, function () {
                    loading(false)
                })
            }

            function requestDataNode(shape, id, callbackSuccess, callbackFail) {
                let endpoint = endpointInputBox.value
                let query = getQueryString(shape, id)
                $.ajax({
                    dataType: "jsonp",
                    url: endpoint + "?query=" + encodeURIComponent(query) + "&format=json",
                    success: function (json, textStatus, jqXHR) {
                        console.log("Show Data Graph request success")
                        console.log(json)
                        console.log(textStatus)
                        console.log(jqXHR)

                        callbackSuccess(json)
                    },
                    error: function (jqXHR, exception) {
                        console.log("Show Data Graph request error:")
                        console.log(jqXHR.status)
                        console.log(exception)
                        let msg = '';
                        if (jqXHR.status === 0) {
                            msg = ': Cannot connect to ShaclAPI';
                        } else if (jqXHR.status === 404) {
                            msg = ': Requested page not found. [404]';
                        } else if (jqXHR.status === 500) {
                            msg = ': Internal Server Error [500].';
                        } else if (exception === 'parsererror') {
                            msg = ': Requested JSON parse failed.';
                        } else if (exception === 'timeout') {
                            msg = ': Time out error.';
                        } else if (exception === 'abort') {
                            msg = ': Ajax request aborted.';
                        } else {
                            msg = ': Uncaught Error.\n' + jqXHR.responseText;
                        }
                        $('#flash').append(flashMessage(msg, 'warning'));

                        callbackFail()

                    }
                });
            }

            function getQueryString(shape, data) {
                let query = 'SELECT DISTINCT ?p ?o WHERE { VALUES ?p {'
                let prefix = shape.prefix.slice(0, -1) ///remove '>'

                {#<http://swat.cse.lehigh.edu/onto/univ-bench.owl#advisor>#}
                {#<http://swat.cse.lehigh.edu/onto/univ-bench.owl#emailAddress>#}
                {#<http://swat.cse.lehigh.edu/onto/univ-bench.owl#name>#}
                {#<http://swat.cse.lehigh.edu/onto/univ-bench.owl#telephone>#}
                {#<http://swat.cse.lehigh.edu/onto/univ-bench.owl#memberOf>#}
                {#<http://swat.cse.lehigh.edu/onto/univ-bench.owl#takesCourse>#}
                shape.childLinks.forEach(link => {
                    if (link.linkType === 1 || link.linkType === 3) {
                        let constraint = getNodeFromLink(link.target);
                        query += prefix + constraint.text + '> '
                    }
                })

                {#<http://www.department0.university0.edu/UndergraduateStudent9>#}
                query += '} OPTIONAL {<' + data + '>?p ?o }}'

                console.log('getQueryString')
                console.log(query)
                return query
            }

            {#// remove test btn
            document.querySelector('#dataGraph').onclick = (e) => {
                showDataGraph(selectedNode, 'http://www.Department0.University0.edu/GraduateStudent100')
            }#}

            {#
            { "head": { "link": [], "vars": ["p", "o"] },
              "results": { "distinct": false, "ordered": true, "bindings": [
                { "p": { "type": "uri", "value": "http://swat.cse.lehigh.edu/onto/univ-bench.owl#emailAddress" }	, "o": { "type": "literal", "value": "UndergraduateStudent36@Department0.University3.edu" }},
                { "p": { "type": "uri", "value": "http://swat.cse.lehigh.edu/onto/univ-bench.owl#memberOf" }	, "o": { "type": "uri", "value": "http://www.Department0.University3.edu" }},
                { "p": { "type": "uri", "value": "http://swat.cse.lehigh.edu/onto/univ-bench.owl#name" }	, "o": { "type": "literal", "value": "UndergraduateStudent36" }},
                { "p": { "type": "uri", "value": "http://swat.cse.lehigh.edu/onto/univ-bench.owl#takesCourse" }	, "o": { "type": "uri", "value": "http://www.Department0.University3.edu/Course34" }},
                { "p": { "type": "uri", "value": "http://swat.cse.lehigh.edu/onto/univ-bench.owl#takesCourse" }	, "o": { "type": "uri", "value": "http://www.Department0.University3.edu/Course27" }},
                { "p": { "type": "uri", "value": "http://swat.cse.lehigh.edu/onto/univ-bench.owl#telephone" }	, "o": { "type": "literal", "value": "xxx-xxx-xxxx" }},
                { "p": { "type": "uri", "value": "http://swat.cse.lehigh.edu/onto/univ-bench.owl#advisor" }} ] } }
            #}

            {#
                returns object with 3 components:
                main: is the requested data node
                nodes: list of all other nodes [constraints, data nodes]
                links: list of all links
            #}

            function creatDataNetwork(shape, id, json) {
                {# clear data graph #}
                let dataGraphNodeList = []
                let dataGraphLinkList = []

                {# to search for constraints #}
                let constraintMap = buildConstraintsMap(shape)

                let dataNode = createDataNode(id, shape, true)

                let jsonConstraintsList = json.results.bindings
                let i = 0
                jsonConstraintsList.forEach(obj => {
                    i += 1

                    if (typeof obj.o == 'undefined') {
                        console.log('creatDataNetwork| Empty: ' + obj.p.value)
                        return;
                    }

                    {#let constraintId = obj.p.value#}
                    let constraintString = obj.p.value.split('#').pop()
                    {#let constraintType = obj.o.type#}
                    let constraintValue = obj.o.value
                    let currentShapeConstraint = constraintMap.get(constraintString)

                    {#if (constraintType == "literal") {#}
                    if (currentShapeConstraint.isAttribute) {
                        // create Attribute Node and link it using one link
                        let attribute = createAttributeNode(i, currentShapeConstraint, dataNode, constraintValue, currentShapeConstraint.min, currentShapeConstraint.max)
                        let link = createLink(i, constraintString, dataNode, attribute, 1, currentShapeConstraint.min, currentShapeConstraint.max)
                        dataGraphNodeList.push(attribute)
                        dataGraphLinkList.push(link)
                    }

                    {#if (constraintType == "uri") {#}
                    if (!currentShapeConstraint.isAttribute) {
                        // create Constraint Node and Data Node then link them with 3 links

                        let n = getNodeFromLink(currentShapeConstraint.childLinks[0].target)
                        let nextDataNode = createDataNode(constraintValue, n, false)

                        let constraint = createConstraintNode(i, currentShapeConstraint, dataNode, constraintString, currentShapeConstraint.min, currentShapeConstraint.max)

                        let link0 = createLink(i, constraintString, dataNode, nextDataNode, 0, currentShapeConstraint.min, currentShapeConstraint.max)
                        let link3 = createLink(i, constraintString, dataNode, constraint, 3, currentShapeConstraint.min, currentShapeConstraint.max)
                        link3.finalTarget = nextDataNode.id
                        let link4 = createLink(i, constraintString, constraint, nextDataNode, 4, currentShapeConstraint.min, currentShapeConstraint.max)
                        dataGraphNodeList.push(constraint, nextDataNode)
                        dataGraphLinkList.push(link0, link3, link4)
                    }
                })
                return {main: dataNode, nodes: dataGraphNodeList, links: dataGraphLinkList}
            }

            {# create data node "almost as shape node" #}

            function createDataNode(id, shape, retrieved) {
                let node = nodesById[id]
                if (node)
                    return node
                else {
                    node = {
                        id: id,
                        group: id,
                        text: id.split('/').pop(),
                        isClass: true,
                        expanded: false,
                        isHidden: false,
                        highlighted: false,
                        childLinks: [],
                        parentLinks: [],
                        query: shape.query,
                        prefix: shape.prefix,
                        targetDef: shape.targetDef,
                        valid: -1,
                        invalid: -1,
                        columns: [],
                        data: [],
                        colorRange: 0 {# 0:unvalidated, 1:allValid, 2:low, 3:medium, 4:high, 5:validating #}
                    }
                    node.shape = shape
                    node.retrieved = retrieved
                    return node;
                }
            }

            function createAttributeNode(incremental, constraint, dataNode, name, min, max) {
                let node = {
                    id: incremental + '|' + dataNode.id + ',' + name,
                    group: dataNode.id,
                    text: name,
                    min: min,
                    max: max,
                    isClass: false,
                    expanded: true,
                    isHidden: false,
                    highlighted: false,
                    childLinks: [],
                    parentLinks: [],
                    isAttribute: true
                }
                node.constraint = constraint
                return node

            }

            function createConstraintNode(incremental, constraint, dataNode, name, min, max) {
                let node = {
                    id: incremental + '|' + dataNode.id + ',' + name,
                    group: dataNode.id,
                    text: name,
                    min: min,
                    max: max,
                    isClass: false,
                    expanded: true,
                    isHidden: false,
                    highlighted: false,
                    childLinks: [],
                    parentLinks: [],
                    isAttribute: false
                }
                node.constraint = constraint
                return node
            }

            {#
            linkType:
             0: class to class
             1: class to attribute
             2: attribute to same class
             3: class to constraint
             4: constraint to other class
             #}

            function createLink(incremental, text, from, to, type, min, max) {

                let link = {
                    id: incremental + '|' + type + '|from:' + from.id + ',to:' + to.id,
                    source: from.id,
                    target: to.id,
                    text: text,
                    min: min,
                    max: max,
                    {#isClass2Class: false,#}
                    {#collapsed: true,#}
                    isHidden: false,
                    highlighted: false,
                    length: getLinkLength(type),
                    {#isAttribute: true,#}
                    linkType: type
                }

                switch (type) {
                    case 0:
                        link.isClass2Class = true
                        link.collapsed = false
                        link.isAttribute = false
                        break;
                    case 1:
                        link.isClass2Class = false
                        link.collapsed = true
                        link.isAttribute = true
                        break;
                    case 3:
                        link.isClass2Class = false
                        link.collapsed = true
                        link.isAttribute = false
                        break;
                    case 4:
                        link.isClass2Class = false
                        link.collapsed = true
                        link.isAttribute = false
                        break;
                    default:
                        return 1
                }

                return link;
            }

            function buildConstraintsMap(shape) {
                let res = new Map()
                shape.childLinks.forEach(link => {
                    if (link.linkType === 1 || link.linkType === 3) {
                        let constraint = getNodeFromLink(link.target);
                        res.set(constraint.text, constraint)
                    }
                })
                return res
            }

            function updateDataGraph(node, callback) {
                loading(true)

                requestDataNode(node.shape, node.id, function (json) {
                    // update node in the data graph and add its constraints

                    // create data graph
                    let graph = creatDataNetwork(node.shape, node.id, json)

                    node.retrieved = true
                    {#nodes.push(...graph.main)#} {# main already added #}
                    nodes.push(...graph.nodes)
                    {# check for each new node if it is already added #}
                    links.push(...graph.links)

                    resetGraphMaps(true)
                    resetShapeCheckList()
                    updateGraph()

                    loading(false)

                    callback()
                }, function () {
                    loading(false)
                })
            }

            document.querySelector('#closeDataGraph').onclick = (e) => {
                document.getElementById('rightButtons').style.display = "none"
                document.getElementById('validationBtn').style.display = "block"
                openRightNav('validation')
                showDataTable()
                showShapeGraph()
            }

            /** todo
             *
             * infoTree combine similar constraints when isShowDataGraph
             * infoTree text icon for data text
             *
             */

            function loading(startLoading) {
                if (startLoading)
                    document.querySelector('#loader').classList.add("loader");
                else
                    document.querySelector('#loader').removeAttribute("class");
            }

            {# remove loader #}
            document.querySelector('#loader').removeAttribute("class");

        </script>

    </div>

{% endblock %}
